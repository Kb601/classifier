cse 431 bboard/mail log




cse 431 - intro to theory of computation 
    bboard/mail log

    spring 1996


this page contains a log of all email sent to the cse431 class
mailing list cse431@cs.  we will use this list for
announcements of general interest to the class.  students should
also feel free to use it to ask questions, post information, or
initiate discussions  of general interest to the class.  of course,
questions or comments that don't seem of general interest can be
directed to the 
ta         (jayram@cs) or 
instructor (ruzzo@cs),
instead.  
  
following usual internet conventions, administrative requests
concerning the mailing list itself, such as add/delete/address
change requests, should be addressed to cse431-request@cs.

index of messages
(latest message friday, 31-may-96 22:25:08 pdt.)


26 mar 96 ruzzo@cs ______ cse 431 mailing list &amp; web
28 mar 96 ruzzo@cs ______ textbook errata
 3 apr 96 jayram@curie __ hw1
 3 apr 96 ruzzo@cs ______ hw1
 4 apr 96 roske@cs ______ hw 1 #3.2
 4 apr 96 claym@cs ______ re: hw1
 4 apr 96 claym@cs ______ re: hw 1 #3.2
 4 apr 96 jmur@cs _______ re: hw1
 4 apr 96 jmur@cs _______ re: hw1
 4 apr 96 claym@cs ______ re: hw1
 4 apr 96 ruzzo@cs ______ re: hw 1 #3.2
 4 apr 96 ruzzo@cs ______ re: hw1
 4 apr 96 ruzzo@cs ______ re: hw1
 4 apr 96 claym@cs ______ re: hw1
 7 apr 96 ruzzo@cs ______ office hours this week
16 apr 96 ruzzo@cs ______ re: cse431: hw #2 questions
16 apr 96 ruzzo@cs ______ re: cse431: hw #2 questions
17 apr 96 roske@cs ______ re: cse431: hw #2 questions
17 apr 96 jayram@cs _____ re: cse431: hw #2 questions 
17 apr 96 ruzzo@cs ______ re: cse431: hw #2 questions
18 apr 96 jayram@cs _____ statistics for hw1
19 apr 96 jayram@curie __ office hours today
22 apr 96 ruzzo@cs ______ office hours/midterm
23 apr 96 ruzzo@cs ______ re: homework #3, 5.7
25 apr 96 ruzzo@cs ______ partner's
26 apr 96 claym@cs ______ apr
27 apr 96 ruzzo@cs ______ exercise
 2 may 96 roske@cs ______ hw #3 problem 5.7
 2 may 96 ruzzo@cs ______ re: hw #3 problem 5.7
 4 may 96 roske@cs ______ hw solution questions
 7 may 96 ruzzo@cs ______ talk today
 7 may 96 ruzzo@cs ______ re: talk today
13 may 96 ruzzo@cs ______ book review
15 may 96 roske@cs ______ hw #4
16 may 96 roske@cs ______ hw 4 prob. 7.30
17 may 96 jayram@cs _____ re: np vx. np 
17 may 96 ruzzo@cs ______ late hw policy
28 may 96 jayram@cs _____ re: proofs
29 may 96 ruzzo@cs ______ re: handout 6
29 may 96 jayram@cs _____ hws etc.
30 may 96 roske@cs ______ hw #5 #7 part (3)
30 may 96 jayram@cs _____ re: hw #5 #7 part (3)
30 may 96 jayram@cs _____ hint for uhampath
30 may 96 jayram@cs _____ hw4
30 may 96 fineman@grizzly a little end-of-the-quarter thought
31 may 96 jayram@hobbes _ solutions for the 3-color and uhampath
31 may 96 jayram@hobbes _ hot off the oven
31 may 96 ruzzo@cs ______ midterm solution
31 may 96 jayram@cs _____ hw5 solutions
31 may 96 jayram@cs _____ solutions to 3-color and uhampath
31 may 96 jayram@cs _____ class web






messages

date: 26 mar 1996 20:59 pst
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: cse 431 mailing list &amp; web


welcome to cse 431!

if you got this message, you're on the cse 431 class mailing list
for spring '96.  we will use this list for announcements of general
interest to the class, and you should also feel free to use it to
ask questions, post information, or initiate discussions.  of
course, questions or comments that don't seem of general interest
can be directed to jayram@cs or ruzzo@cs, instead.  

all mail is also logged to the course web, in case you want to
scroll back though messages you didn't save, etc.

following usual internet conventions, administrative requests
concerning the mailing list itself, such as add/delete/address
change requests, should be addressed to cse431-request@cs.

hope you enjoy the course!
date: 28 mar 1996 23:49 pst
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: textbook errata


i've added a link from the class home page to sipser's page of
errata for his book.  if you see things that look wrong in the text,
check his list to see if you've found a reported bug.  (there are a
handfull in chapter 3, for example.)  if it has not been reported,
and you're pretty sure it's wrong, please send email to me and/or
sipser@math.mit.edu.  [mike is very meticulous.  i'm sure he'd like
to hear about even tiny things like commas out of place before he
creates the final edition of the book.]
date: wed, 3 apr 1996 13:06:52 -0800
from: jayram@curie (jayram thathachar)
to: cse431@cs
subject: hw1


exercise 3.3 deals with enumerators which have not been talked about
in class as yet. that section is quite readable though and you should
be able to understand the proof of theorem 3.9 quite easily. 
both larry and i feel that you should be ableto solve problem 3.3
after going through that material. so it will still be part of the
turn-in on friday. but if any of you have problems, let me know 
and you can submit the solution to that problem alone on monday.

for exercise 3.2, go through the definition of  a non-deterministic
decider quite carefully to understand exactly what you need to show.

-jayram
date: 3 apr 1996 13:32 pst
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: hw1


#3.3 ps: there is no late penalty for turning in #3.3 on monday.  take
a stab at it, i think many of you will have no trouble with it.  but
if you do, don't panic!  i'll talk about enumerators 1st thing
friday .

#3.2: there's a crucial bug in the text related to this problem ---
in the first sentence in the paragraph preceeding corollary 3.8
(p122), it is *not* true that d will always halt if n does.  in
particular, d will run forever on any input w that n rejects, even
though n halts on all paths on input w.
date: thu, 4 apr 1996 17:14:30 -0800 (pst)
from: larry roske &lt;roske@lynx.cs.washington.edu&gt;
to: cse431@lynx.cs.washington.edu
subject: hw 1 #3.2


hi, i have questions regarding homework #1:

first, i don't understand why d will run forever on any input w
that n rejects.  n rejects a string w if it reaches the end of
w and is not in q_accept.  d simulates n with a copy of w on
tape 2, and by following a particular branch of n via the
node addresses given on tape 3.  if some branch results in a
rejecting configuration, why shouldn't d also reject?

second, i'm not sure what is meant by the last sentence on
page 121:  &quot;sometimes a symbol may not correspond to any choice
if too few choices are available for a configuration.&quot;

third, some clarification on #5 (b):  the example add instruction
given combines the use of literal and indirect addressing?  where
literal addressing refers to, what i learned as, an immediate
instruction in cse 378.  so i take it that the &quot;=&quot; symbol means 
that j is a literal or constant, and k up-arrow is an address?

thanks,

--larry




date: thu, 4 apr 1996 18:36:17 -0800 (pst)
from: michael clay &lt;claym@wolf.cs.washington.edu&gt;
to: larry ruzzo &lt;ruzzo@cs.washington.edu&gt;
cc: cse431@cs.washington.edu
subject: re: hw1




on 3 apr 1996, larry ruzzo wrote:

&gt; #3.2: there's a crucial bug in the text related to this problem ---
&gt; in the first sentence in the paragraph preceeding corollary 3.8
&gt; (p122), it is *not* true that d will always halt if n does.  in
&gt; particular, d will run forever on any input w that n rejects, even
&gt; though n halts on all paths on input w.

why does n run forever?  what is it doing, once it has run out
of &quot;lexicographically next strings&quot;?  besides halting in a reject
state, that is.

&gt; #3.3 ps: there is no late penalty for turning in #3.3 on monday.  take
&gt; a stab at it, i think many of you will have no trouble with it.  but
&gt; if you do, don't panic!  i'll talk about enumerators 1st thing
&gt; friday .

i think that this text has enough bugs and the rug has been pulled 
out from under us enough times on this assignment, that the entire 
*assignment* should be due monday, not just 3.3.  

please advise,

	michael (claym@wolf.cs.washington.edu)

date: thu, 4 apr 1996 18:46:38 -0800 (pst)
from: michael clay &lt;claym@wolf.cs.washington.edu&gt;
to: larry roske &lt;roske@cs.washington.edu&gt;
cc: cse431@lynx.cs.washington.edu
subject: re: hw 1 #3.2




on thu, 4 apr 1996, larry roske wrote:

&gt; hi, i have questions regarding homework #1:
&gt; 
&gt; first, i don't understand why d will run forever on any input w
&gt; that n rejects.

neither do i, and i've put my 2 cents in about it.

&gt;                  n rejects a string w if it reaches the end of
&gt; w and is not in q_accept.  d simulates n with a copy of w on
&gt; tape 2, and by following a particular branch of n via the
&gt; node addresses given on tape 3.  if some branch results in a
&gt; rejecting configuration, why shouldn't d also reject?

reread the last two sentences of stage 3 on page 122.  it should
become clear.

&gt; second, i'm not sure what is meant by the last sentence on
&gt; page 121:  &quot;sometimes a symbol may not correspond to any choice
&gt; if too few choices are available for a configuration.&quot;

the sentence following clarifies what sentence in question means.  
the real question is how you get into a situation where a symbol 
does not correspond to any choice in the first place.  reread the
last paragraph on page 121 a few times and you'll figure it out.

hoping i have enlightened more than confused,

	michael (claym@wolf.cs.washington.edu)

date: thu, 4 apr 1996 20:00:59 -0800 (pst)
from: jason murray &lt;jmur@grizzly.cs.washington.edu&gt;
to: michael clay &lt;claym@cs.washington.edu&gt;
cc: larry ruzzo &lt;ruzzo@cs.washington.edu&gt;, cse431@cs.washington.edu
subject: re: hw1



on thu, 4 apr 1996, michael clay wrote:

&gt; 
&gt; 
&gt; on 3 apr 1996, larry ruzzo wrote:
&gt; 
&gt; &gt; #3.2: there's a crucial bug in the text related to this problem ---
&gt; &gt; in the first sentence in the paragraph preceeding corollary 3.8
&gt; &gt; (p122), it is *not* true that d will always halt if n does.  in
&gt; &gt; particular, d will run forever on any input w that n rejects, even
&gt; &gt; though n halts on all paths on input w.
&gt; 
&gt; why does n run forever?  what is it doing, once it has run out
&gt; of &quot;lexicographically next strings&quot;?  besides halting in a reject
&gt; state, that is.

it doesn't run out of lexicographical next strings.  it doesn't say 
anywhere that it halts in a reject state.  the only way to make it halt 
is with an excepting state.



			jason
date: thu, 4 apr 1996 20:04:18 -0800 (pst)
from: jason murray &lt;jmur@grizzly.cs.washington.edu&gt;
to: michael clay &lt;claym@cs.washington.edu&gt;,
        larry ruzzo &lt;ruzzo@cs.washington.edu&gt;, cse431@cs.washington.edu
subject: re: hw1


on thu, 4 apr 1996, jason murray wrote:

&gt; 
&gt; on thu, 4 apr 1996, michael clay wrote:
&gt; 
&gt; &gt; 
&gt; &gt; 
&gt; &gt; on 3 apr 1996, larry ruzzo wrote:
&gt; &gt; 
&gt; &gt; &gt; #3.2: there's a crucial bug in the text related to this problem ---
&gt; &gt; &gt; in the first sentence in the paragraph preceeding corollary 3.8
&gt; &gt; &gt; (p122), it is *not* true that d will always halt if n does.  in
&gt; &gt; &gt; particular, d will run forever on any input w that n rejects, even
&gt; &gt; &gt; though n halts on all paths on input w.
&gt; &gt; 
&gt; &gt; why does n run forever?  what is it doing, once it has run out
&gt; &gt; of &quot;lexicographically next strings&quot;?  besides halting in a reject
&gt; &gt; state, that is.
&gt; 
&gt; it doesn't run out of lexicographical next strings.  it doesn't say 
&gt; anywhere that it halts in a reject state.  the only way to make it halt 
&gt; is with an excepting state.
&gt; 
&gt;			jason
&gt; 


oops, i mean accepting........ :)


		jason
date: thu, 4 apr 1996 20:45:37 -0800 (pst)
from: michael clay &lt;claym@wolf.cs.washington.edu&gt;
to: jason murray &lt;jmur@cs.washington.edu&gt;
cc: larry ruzzo &lt;ruzzo@cs.washington.edu&gt;, cse431@cs.washington.edu
subject: re: hw1




on thu, 4 apr 1996, jason murray wrote:

&gt; &gt; it doesn't run out of lexicographical next strings.  it doesn't say 
&gt; &gt; anywhere that it halts in a reject state.  the only way to make it halt 
&gt; &gt; is with an excepting state.
&gt; 
&gt; oops, i mean accepting........ :)

yeah, i figured that out while trying to answer larry's questions.
like prof. ruzzo said, this is pretty dense reading.  the more i
read, the denser i feel. ;^)

thanks,
	michael (claym@u.washington.edu)
date: 4 apr 1996 20:23 pst
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: larry roske &lt;roske@lynx.cs.washington.edu&gt;
subject: re: hw 1 #3.2
cc: cse431@lynx.cs.washington.edu


other students nicely answered most of this.  i have just a few more
comments.

  &gt; subject: hw 1 #3.2
  &gt; 
  &gt; hi, i have questions regarding homework #1:
  &gt; 
  &gt; first, i don't understand why d will run forever on any input w
  &gt; that n rejects.  n rejects a string w if it reaches the end of
  &gt; w and is not in q_accept.  

you're confusing tm's with finite automata and pda's, where reaching
the end of the input was part of the definition of acceptance.  it's
not part of the definition for tm's.  (where is the end of the input
after i erase it, or add to it or otherwise mangle it?  we could
define it, i suppose, but the tm definition is simpler without it --
you accept if you enter q_accept.  period.

  &gt; d simulates n with a copy of w on
  &gt; tape 2, and by following a particular branch of n via the
  &gt; node addresses given on tape 3.  if some branch results in a
  &gt; rejecting configuration, why shouldn't d also reject?

there are perhaps 2 questions here.  (1) why doesn't it accept:
because d is programmed to do something else when it determines that
n has reached q_reject.  (2) why couldn't we change it to reject:
because then d would accept a different language than n does.  this
is a really important (and often misunderstood) feature of nondet
machines.  in an ntm, q_reject is sort of poorly named.  q_dead-end
might be a better name.  think about the example of accepting
polynomials p(x) having integer roots.  give it, say x^2-1.  what
happens on the path in the tree where it &quot;guesses&quot; x=5?  it
evaluates p(5), gets 25-1 = 24 != 0, and so enters q_reject.  does
that mean p has no integer root?  no!  it just means the particular
guess it was following on that path didn't pan out, but by no means
does it mean that some/many other guesses couldn't work (e.g. x=+-1
in this case).  so bazillions of paths ending in q_reject don't mean
the input is rejected; only the total absence of paths ending in
q_accept mean that it rejects.  yes, very asymmetric.  think of it
like lotto tickets -- just because me and everyone else i happen to
know buy loosing tickets, doesn't mean there isn't a winner.  can i
tell whether there is a winner by looking only at my ticket?  i can
if i'm one of the lucky winners, but not if i'm a looser; you have
to look at all the tickets to verify they're all loosers before you
know for sure there is no winner.

  &gt; second, i'm not sure what is meant by the last sentence on
  &gt; page 121:  &quot;sometimes a symbol may not correspond to any choice
  &gt; if too few choices are available for a configuration.&quot;
  &gt; 
  &gt; third, some clarification on #5 (b):  the example add instruction
  &gt; given combines the use of literal and indirect addressing?  where
  &gt; literal addressing refers to, what i learned as, an immediate
  &gt; instruction in cse 378.  so i take it that the &quot;=&quot; symbol means 
  &gt; that j is a literal or constant, and k up-arrow is an address?

yes.  (the syntax isn't important, of course, just happens to be what
i remember from the tyranasauriac assembler.)
date: 4 apr 1996 21:13 pst
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: michael clay &lt;claym@wolf.cs.washington.edu&gt;
subject: re: hw1
cc: cse431@cs.washington.edu


    i think that this text has enough bugs and the rug has been pulled 
    out from under us enough times on this assignment, that the entire 
    *assignment* should be due monday, not just 3.3.  

hmmm...  i think there was only that one bug relevant to this
assignment (which is listed on sipser's web errata page by the way),
so i don't think you should need more time, but if you really really
want it, i guess i could take #3.2 on monday also.

by the way, i hate having a book with errors, too.  so far, even
though this one is labeled &quot;preliminary edition&quot;, i havn't found it
any worse that 10 year old n-th editions i've used, and the online
errata list is much better than usual.  the good news should be that
knowing there are errors in the book might nudge us all to read
it more carefully -- not an altogether bad habit.
date: 4 apr 1996 21:42 pst
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: jason murray &lt;jmur@grizzly.cs.washington.edu&gt;
subject: re: hw1
cc: cse431@cs.washington.edu



  &gt; date: thu, 4 apr 1996 20:00:59 -0800 (pst)
  &gt; from: jason murray &lt;jmur@grizzly.cs.washington.edu&gt;
  &gt; to: michael clay &lt;claym@cs.washington.edu&gt;
  &gt; cc: larry ruzzo &lt;ruzzo@cs.washington.edu&gt;, cse431@cs.washington.edu
  &gt; subject: re: hw1
  &gt; 
  &gt; on thu, 4 apr 1996, michael clay wrote:
  &gt; 
  &gt; &gt; on 3 apr 1996, larry ruzzo wrote:
  &gt; &gt; 
  &gt; &gt; &gt; #3.2: there's a crucial bug in the text related to this problem ---
  &gt; &gt; &gt; in the first sentence in the paragraph preceeding corollary 3.8
  &gt; &gt; &gt; (p122), it is *not* true that d will always halt if n does.  in
  &gt; &gt; &gt; particular, d will run forever on any input w that n rejects, even
  &gt; &gt; &gt; though n halts on all paths on input w.
  &gt; &gt; 
  &gt; &gt; why does n run forever?  what is it doing, once it has run out
  &gt; &gt; of &quot;lexicographically next strings&quot;?  besides halting in a reject
  &gt; &gt; state, that is.
  &gt; 
  &gt; it doesn't run out of lexicographical next strings.  it doesn't say 
  &gt; anywhere that it halts in a reject state.  the only way to make it halt 
  &gt; is with an excepting state.

small clarification: that particular algorithm never enters a reject
state; other tm's sometimes do and they always halt if they do.  (i
was afraid someone would misread your statement as saying that
q_reject is not a halting state; it is.)
date: thu, 4 apr 1996 22:09:19 -0800 (pst)
from: michael clay &lt;claym@wolf.cs.washington.edu&gt;
to: larry ruzzo &lt;ruzzo@cs.washington.edu&gt;
cc: cse431@cs.washington.edu
subject: re: hw1




on 4 apr 1996, larry ruzzo wrote:

&gt;     i think that this text has enough bugs and the rug has been pulled 
&gt;     out from under us enough times on this assignment, that the entire 
&gt;     *assignment* should be due monday, not just 3.3.  
&gt; 
&gt; hmmm...  i think there was only that one bug relevant to this
&gt; assignment (which is listed on sipser's web errata page by the way),

it wasn't in the errata last week (last updated 2/5/96.)
interestingly enough, the errata (last updated 3/27/96) now
shows that you submitted this bug 3/29/96.  is the author 
psychic or do we need errata for the errata.

&gt; so i don't think you should need more time, but if you really really
&gt; want it, i guess i could take #3.2 on monday also.

am i the only one who has gotten stuck beating his head on the 
first (buggy) problem and second (not covered yet) problem?  
if so, i would have expected to see more questions on the following
problems than have been posted to the group.

i personally didn't finish the third problem till just a few minutes 
ago and am not looking forward to working on the fourth and fifth 
problems till the wee hours of the morning.

&gt; by the way, i hate having a book with errors, too.  so far, even
&gt; though this one is labeled &quot;preliminary edition&quot;, i havn't found it
&gt; any worse that 10 year old n-th editions i've used, and the online
&gt; errata list is much better than usual.

my more cynical side suggests that the errata list is short because
the text hasn't been around long enough to collect many bug reports.  
(the earliest listed erratum is only 11/22/95!)

&gt;                                         the good news should be that
&gt; knowing there are errors in the book might nudge us all to read
&gt; it more carefully -- not an altogether bad habit.

this would be pretty dense reading even without the bugs.
just my 2 cents worth.

see you after problem# 4.

	michael (claym@wolf.cs.washington.edu)

date: 7 apr 1996 23:39 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: office hours this week


jayram and i are switching our monday/friday hours this week:
    monday 4/8 : 1:00-2:00 ruzzo  sieg 415
    friday 4/12: 1:00-2:00 jayram sieg 326 (i think)
date: 16 apr 1996 21:18 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: re: cse431: hw #2 questions


    i have a couple of questions i hope you can answer for me.  in
    ex. 4.17 is the language c accepting prefixes of the strings d
    accept?

not quite.  in &quot;xy&quot;, x is a prefix, perhaps without any clear
boundary marking the end of x from the begining of y, but in &quot;&lt;x,y&gt;&quot;
they're encoded so that the boundary between x and y is clearly
visible.  e.g. perhaps x and y are from an alphabet like {0,1} that
lacks the &quot;,&quot;, &quot;&lt;&quot;, and &quot;&gt;&quot; characters, and &quot;&lt;x,y&gt;&quot; means literally
stick x and y together with those three punctuation characters.

    in doing our proof i assume we as usual have got to show both
    directions of the statement we are to prove.  in this case, we
    would have to show 1) when c is enumerable we must construct d
    and 2) when we have d that c is enumberable, is this correct or
    am i totally off on a tangent here?

just right.
date: 16 apr 1996 23:20 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: re: cse431: hw #2 questions


    in ex. 3.9 &amp; 3.10 is it sufficient to give informal descriptions
    of the tm's that would accept these languages?  also i have some
    trouble seeing the difference between 3.9 &amp; 3.10.  when doing
    3.9 i'm constructing tm's that accept these languages (i.e. when
    concatenating l=l1l2) and using the &quot;sublanguages&quot; (in this case
    l1 and l2) as subroutines.  in 3.10 couldn't i just do the same
    while just being careful from depending on subroutines that
    might loop?

yes, the key difference between 3.9 and 3.10, i.e. between deciders
and acceptors, is that you must be careful that the former
always halt, and that looping in the later doesn't cause inputs
to be rejected when you don't want them to be rejected.

&quot;informal descriptions&quot;: through out the rest of the quarter, unless
otherwise specified, i want &quot;high level descriptions&quot; as discussed
on page 127.

 two small points: 
  1) in 3.9 you're constructing tm's that &quot;decide&quot; these languages,
not merely &quot;accept&quot;.
  2) l1 and l2 aren't subroutines, although machines that
decide or accept them can be.  i hate to be pedantic about small
points like this, but i think students get themselves confused,
sometimes deeply confused, by a collection of small things like
this.  l1 is a language, i.e. a set of strings; if l1 is decidable
there is some program/tm, say m1, that distinguishes those strings
in l1 from those strings not in l1. (and there may be lots of other
programs that can also do this job.)
date: wed, 17 apr 1996 04:53:23 -0700 (pdt)
from: larry roske &lt;roske@lynx.cs.washington.edu&gt;
to: larry ruzzo &lt;ruzzo@cs.washington.edu&gt;
cc: cse431@cs.washington.edu
subject: re: cse431: hw #2 questions


i see that for enumerable union we need to avoid looping to
check acceptance by one or the other tm, but is this necessary
for enumerable cat, star, and intersection since if the
first tm loops (in cat or intersection) this doesn't accept
which is what we want anyway in these cases?

on 16 apr 1996, larry ruzzo wrote:

&gt; yes, the key difference between 3.9 and 3.10, i.e. between deciders
&gt; and acceptors, is that you must be careful that the former
&gt; always halt, and that looping in the later doesn't cause inputs
&gt; to be rejected when you don't want them to be rejected.
&gt; 
to: larry roske &lt;roske@lynx.cs.washington.edu&gt;
cc: cse431@cs.washington.edu
subject: re: cse431: hw #2 questions 
in-reply-to: your message of &quot;wed, 17 apr 1996 04:53:23 pdt.&quot;
             &lt;pine.ult.3.91.960417044845.956a-100000@lynx.cs.washington.edu&gt; 
date: wed, 17 apr 1996 08:38:40 pdt
from: ------------------------------------------------------------------------ &lt;jayram@arnica.cs.washington.edu&gt;


&gt;&gt;&gt;&gt;&gt; &quot;lr&quot; == larry roske &lt;roske@lynx.cs.washington.edu&gt; writes:

lr&gt; i see that for enumerable union we need to avoid looping to check
lr&gt; acceptance by one or the other tm, but is this necessary for
lr&gt; enumerable cat, star, and intersection since if the first tm loops
lr&gt; (in cat or intersection) this doesn't accept which is what we want
lr&gt; anyway in these cases?

you have to be careful about concatenation and star. note that if w
belongs to k.l for two languages k and l, w can be written as uv,
where u is in k and v is in l. but the crucial thing is that the
decomposition is **not known in advance**, meaning that
w itself does not encode where u ends and v begins.
furthermore, the decomposition may not be unique.

contrast this with the language 
{ &lt;u,v&gt; | u in k and v in l }
where from the input w=&lt;u,v&gt;, we can extract the two parts u and v in
a unique way.

similar remarks apply for star as well.

-jayram.


date: 17 apr 1996 08:49 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: larry roske &lt;roske@lynx.cs.washington.edu&gt;
subject: re: cse431: hw #2 questions
cc: cse431@cs.washington.edu, larry &lt;ruzzo@cs.washington.edu&gt;


that's ok for intersection, but not clear to me for cat or star.
to: cse431@cs
subject: statistics for hw1
date: thu, 18 apr 1996 11:07:46 pdt
from: ------------------------------------------------------------------------ &lt;jayram@arnica.cs.washington.edu&gt;


low: 22
high: 48
avg: 39.1

each question was worth 10pts for a total of 50.
-jayram.
date: fri, 19 apr 1996 11:58:00 -0700
from: jayram@curie (jayram thathachar)
to: cse431@cs
subject: office hours today


prof. ruzzo will not be holding office hours today. please send mail
to him if you need to meet him.

-jayram.
date: 22 apr 1996 13:03 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: office hours/midterm


1) effective today, mondays 1:00-2:00 office hour will  be ruzzo
(415 sieg) &amp; fridays 1:00-2:00 will be jayram (sieg326).  i.e. times
are unchanged, but we've traded days.  other previously announced
hours are unchanged.

2) midterm will be in class, monday may 6.
date: 23 apr 1996 21:57 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: david mears &lt;dmears@grizzly.cs.washington.edu&gt;
subject: re: homework #3, 5.7
cc: cse431@cs


  &gt; date: tue, 23 apr 1996 21:28:37 -0700 (pdt)
  &gt; from: david mears &lt;dmears@grizzly.cs.washington.edu&gt;
  &gt; subject: homework #3
  &gt; 
  &gt; problem 3 ( exercise 5.7 ) on the new homework has me wondering what the
  &gt; definition of an 'enumerable problem' is.  it seems like it should go 
  &gt; something like this:
  &gt; 
  &gt; we say that a problem is enumerable if it can be restated as a test for 
  &gt; membership in an enumerable language.
  &gt; 
  &gt; is this correct?

yes.  i'd even go further and say, at least for purposes of this
exercise, that &quot;enumerable problem&quot; and &quot;enumerable language&quot; are
synonyms.
date: 25 apr 1996 11:20 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: partner's


if you have not yet arranged a partner for prob 1 on the next hw
assignment, please let me know as soon as possible.
date: fri, 26 apr 1996 09:55:11 -0700 (pdt)
from: michael clay &lt;claym@wolf.cs.washington.edu&gt;
to: cse431@cs.washington.edu


the errata list has more than doubled since the start of class, including 
some new errata for chapter 5.  if you haven't downloaded the errata list 
recently, you should.

cheer,
	michael &lt;claym@wolf.cs.washington.edu&gt;
date: 27 apr 1996 15:10 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: exercise


at the end of class on friday, i suggested you think about , before
monday's class, what questions about c programs are decidable
vs undecidable.  as another slant on this, what programming errors
could you catch at compile time?  the following talk announcement
that happened to come out yesterday may give you some food for
thought.  don't worry if you don't understand all the buzz words in
this; i don't either.

ps: nelson's a good guy; the talk might be interesting (but i'm
certainly not suggesting that it's part of your 431 homework).
  &gt;  _________________________________
  &gt; from voting-faculty-request@june fri apr 26 11:09:28 1996
  &gt; date: fri, 26 apr 1996 10:33:06 -0700 (pdt)
  &gt; from: scott dakins &lt;sjdakins@cs.washington.edu&gt;
  &gt; to: talks@cs.washington.edu
  &gt; subject: uw-cse colloq / 5-7-96 / nelson / dec systems research center 
          / extended static checking
  &gt; 
  &gt; university of washington
  &gt; seattle, washington 98195
  &gt; 
  &gt; department of computer science and engineering
  &gt; box 352350
  &gt; (206) 543-1695
  &gt; 
  &gt; colloquium
  &gt; 
  &gt; speaker:	greg nelson
  &gt; 		dec systems research center
  &gt; 
  &gt; title:		extended static checking
  &gt; 
  &gt; date:		tuesday, may 7, 1996
  &gt; 
  &gt; time:		3:30 pm	
  &gt; 
  &gt; place:		134 sieg hall
  &gt; 
  &gt; host:		anna karlin
  &gt; 
  &gt; abstract:
  &gt; 
  &gt; i'll describe a system for detecting at compile time certain programming
  &gt; errors that are not normally detected until run time, and sometimes
  &gt; not even then.  for example, array bounds errors and nil dereferences.
  &gt; a special novelty of the system is its ability to detect race conditions
  &gt; and deadlocks in multi-threaded programs.  
  &gt; 
  &gt; the system requires the programmer to annotate procedure declarations 
  &gt; with simple preconditions and postconditions.  these annotations 
  &gt; are much less onerous than the annotations that would be required 
  &gt; for a full program correctness proof.  
  &gt; 
  &gt; the checking is totally automatic. the checker reports errors by line number. 
  &gt; 
  &gt; the system is implemented for modula-3, and handles essentially 
  &gt; all features of the modula-3 safe language, including references, 
  &gt; objects with single inheritance, and concurrency.  many parts of 
  &gt; the standard library for modula-3 have been checked with the system, 
  &gt; including the object-oriented input-output stream library and the 
  &gt; generic sequence library. 
  &gt; 
  &gt; 
  &gt; refreshments to follow.
  &gt; 
  &gt; 
  &gt; email: talk-info@cs.washington.edu
  &gt; 
  &gt; info: http://www.cs.washington.edu
  &gt; 
  &gt; 
date: thu, 2 may 1996 19:24:14 -0700 (pdt)
from: larry roske &lt;roske@lynx.cs.washington.edu&gt;
to: cse431@lynx.cs.washington.edu
subject: hw #3 problem 5.7


since a_tm is enumerable, can't we just use theorem 5.22 which
says that if a &lt;=m b, and b is enumerable, then a is enumerable?

--larry

date: 2 may 1996 21:39 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: larry roske &lt;roske@lynx.cs.washington.edu&gt;
subject: re: hw #3 problem 5.7
cc: cse431@lynx.cs.washington.edu


theorem 5.22 is an &quot;if&quot;, not an &quot;if and only if&quot;.

  &gt; date: thu, 2 may 1996 19:24:14 -0700 (pdt)
  &gt; from: larry roske &lt;roske@lynx.cs.washington.edu&gt;
  &gt; to: cse431@lynx.cs.washington.edu
  &gt; subject: hw #3 problem 5.7
  &gt; 
  &gt; since a_tm is enumerable, can't we just use theorem 5.22 which
  &gt; says that if a &lt;=m b, and b is enumerable, then a is enumerable?
date: sat, 4 may 1996 21:17:28 -0700 (pdt)
from: larry roske &lt;roske@lynx.cs.washington.edu&gt;
to: cse431@lynx.cs.washington.edu
subject: hw solution questions


jayram, 

after more careful reading of the homework solutions i 
wanted to clarify a couple of things:

hw #1 solution:  (just errata i think)
  1. for problem 4, part a., first sentence:  0,1* should be {0,1}* ?

  2. for same problem, part b., 4th line:  u^r should just be u ?

hw #2 solution:
  1. problem 5:  you used a^t instead of just a number t.  is this
     because you wanted to encode the number as a string?

hw #3 solution:
  1. 5.7:  how would we write the solution using the format used
     in text and lecture--as follows?

     the following machine f computes a reduction f:
     f = &quot;on input x:
       1. if x != &lt;m, w&gt; for any tm &lt;m, w&gt;, then output some fixed
          y0 not_in a_tm.

       2. otherwise, build m' and output &lt;m', w'&gt;, where

          m'(m_l) = &quot;on input w:
            1. run m_l on w
            2. if m_l accepts, then accept; else reject.

     where m'(m_l) means m' is parameterized with m_l, a tm that
     accepts any enumerable language.

thanks,

--larry


date: 7 may 1996 11:30 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: talk today


a reminder, on the off chance that you were interested in the talk i
mentioned...
  &gt;  _________________________________
  &gt; from voting-faculty-request@june tue may  7 11:21:55 1996
  &gt; to: cs-grads@geoduck, uw-systems@geoduck, faculty@geoduck
  &gt; subject: colloquium reminder
  &gt; date: tue, 07 may 1996 11:19:37 pdt
  &gt; from: anna karlin &lt;karlin@geoduck.cs.washington.edu&gt;
  &gt; 
  &gt; 
  &gt; greg nelson from dec systems research center is giving a colloquium
  &gt; today at 3:30 on extended static checking.
  &gt; he's a really good guy, who's done great work in numerous areas
  &gt; of computer science including programming languages, theorem
  &gt; proving and distributed systems.
  &gt; it should be a really interesting talk.
  &gt; 
  &gt; 
date: 7 may 1996 13:02 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: kestutis sereiva &lt;kestas@grizzly.cs.washington.edu&gt;
subject: re: talk today
cc: cse431@cs


in 134 sieg.
date: 13 may 1996 09:35 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: book review


i think i told you i will be sending the publisher a review of
sipser's book (in preparation for his final edition).  i'll probably
compose it next weekend.  if you have comments about the book,
please send them to me and i'll forward them.
date: wed, 15 may 1996 20:40:43 -0700 (pdt)
from: larry roske &lt;roske@lynx.cs.washington.edu&gt;
to: cse431@lynx.cs.washington.edu
subject: hw #4


fyi, in problem 7.13, the a refers to some language in p.

--larry

date: thu, 16 may 1996 22:09:20 -0700 (pdt)
from: larry roske &lt;roske@lynx.cs.washington.edu&gt;
to: cse431@lynx.cs.washington.edu
subject: hw 4 prob. 7.30


i'm trying to polynomially reduce 2sat to path, and then
by theorem 7.25, (if a &lt;=p b, and b is in p, then a is in p)
2sat would be in p as desired, but am having difficulty.
any suggestions/insight, or would another strategy be easier?

thanks,

--larry

to: wade barrett &lt;wbarrett@wolf.cs.washington.edu&gt;
cc: ruzzo@cs, cse431@cs
subject: re: np vx. np 
in-reply-to: your message of &quot;fri, 17 may 1996 11:45:15 pdt.&quot;
             &lt;pine.ult.3.91.960517113836.21494b-100000@wolf.cs.washington.edu&gt; 
date: fri, 17 may 1996 12:20:50 pdt
from: &quot;jayram s. thathachar&quot; &lt;jayram@arnica.cs.washington.edu&gt;


&gt;&gt;&gt;&gt;&gt; &quot;wb&quot; == wade barrett &lt;wbarrett@wolf.cs.washington.edu&gt; writes:

wb&gt; could you please tell me exactly what was being proved at the end
wb&gt; of class?  i would like to try to prove it myself.

the two formulations of np were

l is in np if

(*) there is a poly-time verifier for l.

(**) there is a poly-time ntm that decides l.

proof:
(*) ==&gt; (**)

suppose there is a verifier v for l that takes a pair &lt;x,y&gt; and
accepts/rejects in time |x|^k then the poly-time ntm that
decides  l works as follows:

on input x:
  guess y of length |y|^k.
  accept iff v accepts &lt;x,y&gt;.

(**) ==&gt; (*)
suppose the ntm n decides l in time n^s.
the poly-time verifier v should take a pair &lt;x,y&gt; and accept/reject
&lt;x,y&gt; in time polynomial in |x| so that

a. if x is in l, then for some y, v accepts &lt;x,y&gt;
b. if x is not in l, then for all y, v rejects &lt;x,y&gt;

hint: use the simulation of ntms by dtms (i'm not sure but i think it
is theorem 3.7) to do this.

if you recall, this is similar to the hw problem that showed that a
language c is enumerable if and only if there is a decidable language
d such that
a. if x is in c, then for some y, &lt;x,y&gt; is in d
b. if x is not in c, then for all y &lt;x,y&gt; is not in d.

thus the dtm that decides d is the verifier for the enumerable language
c (with no restrictions on running time). in some sense, the class of
enumerable languages are to np as the class of decidable languages to p.
date: 17 may 1996 22:27 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: late hw policy


just got back to town, to find several messages asking about late
homework.  my usual policy is -10% for late papers, so if you didn't
turn anything in today, or only turned in part of the assignment,
it's certainly worth your while to try to finish it over the weekend.
sender: jayram@cs.washington.edu
date: tue, 28 may 1996 21:26:13 -0700
from: jayram thathachar &lt;jayram@cs.washington.edu&gt;
to: cse431@cs
subject: re: proofs
references: &lt;pine.ult.3.91.960528204720.23910a-100000@wolf.cs.washington.edu&gt;


the language u in problem 1(ex 7.23) is very similar to atm, in the
sense it is &quot;universal&quot;. use what you know about atm to figure this one
out.

&gt; on problems 1 and 2 we need to show:
&gt; (a) that some language l is in np
&gt; (b) that every other language in np is &lt;=p l, either directly or
&gt;     indirectly by reduction from some known np-complete language.
&gt; 
&gt; i'm having no problem with part (a), but i'm having a really difficult
&gt; time trying to find suitable reductions for part (b).  none of the
&gt; np-complete languages we've covered in class seem suitable.
-- 
jayram s. thathachar                  jayram@cs.washington.edu
department of cse              http://www.cs.washington.edu/homes/jayram
university of washington              +1 206 616-1843 (vox)
box 352350, seattle, wa 98195         +1 206 543-2969 (fax)
date: 29 may 1996 08:37 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: re: handout 6



  &gt; date: wed, 29 may 1996 08:25:45 -0700 (pdt)
  &gt; subject: handout 6
  &gt; 
  &gt; in handout 6, problem 3c, i am getting a little lost in the notation.
  &gt; a few questions:
  &gt; 
  &gt; a)  each x(i) seems to be each unique variable, made even more unique
  &gt;     by whether it is negated or not?

yes, there are m different variables.

  &gt; b)  &quot;suppose 'x(i)' occurs in clauses numbered i(1),...,i(j)....&quot; 
  &gt;     does this mean that the variable must occur in each clause 
  &gt;     between i and j, inclusive?  (obviously, the same question applies
  &gt;     for the negated version.)

no, not &quot;inclusive&quot;: if x3 appears (not negated) in clauses 2, 3, 12
and 17, then j=4 and i1=2, i2=3, i3=12 and i4=17 and
a3=2+3+12+17=34.  (really i should have used double subscripts or
something, because j and the the i_k's will likely be different for
each xi, but i was trying to keep it simple.); 

  &gt; c)  &quot;let a(i) = (summation from k=1 to j) i(k).&quot;  does this mean that
  &gt;     a(i) is the number of times that a unique variable appears, including
  &gt;     p[aossible repeats in a clause?  (once again, same question for the
  &gt;     negated variable.)

as above, it's the sum of the clause numbers in which the variable
appears.

  &gt; d)  &quot;let s = (summation from i=1 to q) i.&quot;  is this just the number
  &gt;     of clauses in f?

no.  s=1+2+3+...+q, where q is the number of clauses.

  &gt; sorry about all the questions, but obviously i can't answer the 
  &gt; question if i don't understand the details!

no problemo.
sender: jayram@cs.washington.edu
date: wed, 29 may 1996 11:17:15 -0700
from: jayram thathachar &lt;jayram@cs.washington.edu&gt;
to: cse431@cs
subject: hws etc.


i will hold special office hours tomorrow(thursday) from 1-2 in sieg
326(undergraduate lounge)for those  who need help on the problems due
friday. 
here is the plan for returning hws.

the graded hw4 will be handed back tomorrow during my office hours. i
will post the solutions today on the class web and also have copies of
it tomorrow. on friday, i'll return hw5(whichever part was handed in
today) with the solutions to all the hw5 problems. note that i also have
office hours on friday from 1-2.

since i will be moving to a new place, i will not be in school this
weekend. if you send me e-mail about clarifications, i'll try as much as
possible to reply to them.

-jayram.
-- 
jayram s. thathachar                  jayram@cs.washington.edu
department of cse              http://www.cs.washington.edu/homes/jayram
university of washington              +1 206 616-1843 (vox)
box 352350, seattle, wa 98195         +1 206 543-2969 (fax)
date: thu, 30 may 1996 18:54:27 -0700 (pdt)
from: larry roske &lt;roske@lynx.cs.washington.edu&gt;
to: cse431@lynx.cs.washington.edu
subject: hw #5 #7 part (3)


the hint suggests using the tm m_sat as a subroutine to
determine if x1=0 or x1=1 is &quot;part&quot; of a satisfying assignment.

since m_sat accepts strings w in sat, and sat consists of
formulas with satisfying assignments for all variables,
can't we use m_sat to test for a particular assignment to all of the
variables at one time, e.g. x1=0, x2=1, x3=0, etc.?

ah ha! i think this is because we would have to try each
permutation of assignments which would create an exponential
time computation?

--larry

date: thu, 30 may 1996 19:28:16 -0700 (pdt)
from: jayram thathachar &lt;jayram@curie.cs.washington.edu&gt;
to: larry roske &lt;roske@lynx.cs.washington.edu&gt;
cc: cse431@lynx.cs.washington.edu
subject: re: hw #5 #7 part (3)


on thu, 30 may 1996, larry roske wrote:

&gt; the hint suggests using the tm m_sat as a subroutine to
&gt; determine if x1=0 or x1=1 is &quot;part&quot; of a satisfying assignment.
&gt; 
&gt; since m_sat accepts strings w in sat, and sat consists of
&gt; formulas with satisfying assignments for all variables,
&gt; can't we use m_sat to test for a particular assignment to all of the
&gt; variables at one time, e.g. x1=0, x2=1, x3=0, etc.?
&gt; 
&gt; ah ha! i think this is because we would have to try each
&gt; permutation of assignments which would create an exponential
&gt; time computation?
&gt; 
&gt; --larry
&gt; 
&gt; 

that's right. btw, for those of you who were there during the office 
hours, the general definition of self-reducibility that i gave is 
completely wrong. i said that l is self-reducible if there is a poly-time 
reduction f such that x \in l iff f(x) \in l *and* |f(x)|&lt;|x|.

the correct definition is that l is self-reducible if there is a poynomial
time algorithm that can use the subroutine p for l as a black-box but any
calls p(y) made to p must use a y smaller in length than x. 

what follows is an explanation of why the definition i gave is wrong and 
is irrelevant to the hw problem in question. 

the definition that i gave is something else. if you think about it, by
applying f repeatedly, that is, let y=f(f(...(x)...)) so that y becomes
small enough, in constant time i can determine if y is in l and
conclude if x is in l. computing y takes only polynomial time since i have
to apply f at most |x| times so l must be in p if it is self-reducible.

-jayram.



date: thu, 30 may 1996 20:09:20 -0700 (pdt)
from: jayram thathachar &lt;jayram@curie.cs.washington.edu&gt;
to: cse431@cs
subject: hint for uhampath


let's see. the only help i can give here is the following. this is a hint 
if you are using hampath to reduce to uhampath.

let g' be the undirected graph obtained from g.
suppose we want to make sure that in g', when entering a
vertex u, we always do so from a vertex x such that x-&gt;u is an edge in 
g. and while leaving u, we always use a vertex y such that u-&gt;y is an edge 
in g. can you enforce this condition by adding extra vertices and making 
sure that any hamiltonian path in g' must obey this rule?

-jayram.
--
jayram s. thathachar                  jayram@cs.washington.edu
department of cse              http://www.cs.washington.edu/homes/jayram
university of washington              +1 206 616-1843 (vox)
box 352350, seattle, wa 98195         +1 206 543-2969 (fax)



date: thu, 30 may 1996 20:17:28 -0700 (pdt)
from: jayram thathachar &lt;jayram@curie.cs.washington.edu&gt;
to: cse431@cs
subject: hw4


on the problem of p being closed under star, two of you came up with a
nice observation of what the fill-in-the-table algorithm was doing and
i thought i'd share it with you. 

let l be the language in p and we want to show that l^* is in p. for an
input w=a_1 a_2 ... a_n, suppose we define a directed graph g on
{1,2,...,n+1} as follows: there is an edge from i to j iff a_i ... a_{j-1}
is in l. then, 
   w is in l^* iff there is a path from 1 to n+1 in g.

the table algorithm that i gave in the solution set was just doing bfs on 
this graph.

--
jayram s. thathachar                  jayram@cs.washington.edu
department of cse              http://www.cs.washington.edu/homes/jayram
university of washington              +1 206 616-1843 (vox)
box 352350, seattle, wa 98195         +1 206 543-2969 (fax)


date: thu, 30 may 1996 22:32:04 -0700
from: fineman@grizzly (dan fineman)
to: cse431@cs
subject: a little end-of-the-quarter thought



every horse has an infinite number of legs (proof by intimidation):

horses have an even number of legs.  behind they have two legs, and in
front they have fore-legs.  this makes six legs, which is certainly an
odd number of legs for a horse.  but the only number that is both even
and odd is infinity.  therefore, horses have an infinite number of
legs.  now to show this for the general case, suppose that somewhere,
there is a horse that has a finite number of legs.  but that is a
horse of another color, and by the [above] lemma [&quot;all horses are the
same color&quot;], that does not exist.
 
date: fri, 31 may 1996 13:05:12 -0700
from: jayram@hobbes (jayram thathachar)
to: cse431@cs
subject: solutions for the 3-color and uhampath


it looks like i'll get to them after the office hours. bear
with me for this inconvenience. i have the solutions for
the 4th and 7th problem ready.
-jayram.
date: fri, 31 may 1996 17:10:17 -0700
from: jayram@hobbes (jayram thathachar)
to: cse431@cs
subject: hot off the oven


solutions to the hw will be available outside larry's door in about
15-20mts. your hws should have been handed in by now. i'll also
e-mail the solutions to 3-color and uhampath soon and finally
everything should be on the web later this evening.
-jayram.
date: 31 may 1996 17:14 pdt
from: larry ruzzo &lt;ruzzo@quinault.cs.washington.edu&gt;
to: cse431@cs
subject: midterm solution


a few copies will also be available outside my door, and it should be 
on the web already.
sender: jayram@cs.washington.edu
date: fri, 31 may 1996 18:03:03 -0700
from: jayram thathachar &lt;jayram@cs.washington.edu&gt;
to: cse431@cs
subject: hw5 solutions


solutions to hw5 are available outside larry's door.
-jayram.

-- 
jayram s. thathachar                  jayram@cs.washington.edu
department of cse              http://www.cs.washington.edu/homes/jayram
university of washington              +1 206 616-1843 (vox)
box 352350, seattle, wa 98195         +1 206 543-2969 (fax)
sender: jayram@cs.washington.edu
date: fri, 31 may 1996 22:04:36 -0700
from: jayram thathachar &lt;jayram@cs.washington.edu&gt;
to: cse431@cs
subject: solutions to 3-color and uhampath


for those of you who were unable to pick up the solutions outside
larry's door.
********************************************************************
solution sketches to 3-color and uhampath
********************************************************************
3-color is np-complete:

3-color is in np via a verifier that, in polynomial time, using a
coloring of the vertices of the  graph as a certificate, can verify
that the coloring is a valid 3-coloring of g.

we will reduce 3cnf-sat to 3-color. let \phi be a 3-cnf formula.
the graph that we build in polynomial time has the vertex set
{t,f,o} \union set of literals \union set of clauses \union other
vertices.

here are the edges in g, classified by their type:

         o
(a)     /\
       /  \
      /    \
     /      \
    /--------\
    t        f


(b) for each variable x:

        o
        /\
       /  \
      /    \
     /      \  _
  x /--------\ x


(c) (the or-gadget) for each clause c = p \or q \or r

o___________c_____________f
|           /\
|          /  \
|         /    \
|        /      \
|       /--------\
|       |        |
|_______|        |
        /\       |
       /  \      |
      /    \     |
     /      \    |
    /--------\   |
    |        |   |
    |        |   |
    |        |   |
    p        q   r


in any valid 3-coloring, because of edges of type (a), the vertices t,
f and o get the 3 different colors. let the colors that they get
itself be named t, f and o. therefore, each vertex gets colored t, f
or o in any legal 3-coloring.

because of edges of type (b), for any variable x, x and not(x) get
different colors in {t,f}. thus, a legal 3-coloring can always be used
to define an assignment of 0-1 values to the variables.

finally, the or-gadget satisfies the following property:
suppose in the or-gadget corresponding to the clause c=p \or q \or r,
p, q, and r are each constrained to get colors from {t,f}. then,

   there is a legal 3-coloring of the or-gadget with the clause
   getting colored t iff at least one of p, q, r is colored t.

this can be checked by trying out the various combinations of color
assignments to the nodes in the gadget. (you may find it easier to work
with the or-gadget given in the book for 2 literals and then get it to
work for 3).

thus the formula is satisfiable iff every clause is satisfied by some
assignment iff there is a legal 3-coloring of g.

*****************************************************************

uhampath is np-complete

to show that uhampath belongs to np, the verifier takes the encoding
of hamiltonian path as a certificate and verifies that the certificate
indeed corresponds to a hamiltonian path in the input graph.

we will reduce hampath to uhampath as follows:
suppose &lt;dg,s,t&gt; is an instance of hampath. let dg=(v,e)
we will create a undirected graph ug as follows:
the vertex set for ug is {v_i, v_m, v_o : v \in v} u {s',t'}

informally, we will force any hamiltonian path between s' and t'
in ug to always correspond to a directed path in g (the subscripts for
the vertices refer to ``in'', ``middle'' and ``out'').

the edges for ug are

(a) for each vertex v in v,

     v_i ----- v_m ------ v_o

(b) for each edge u--&gt;v in e,

    u_o ----- v_i

(c) an edge s'----s_i and an edge t_o----t'

claim: there is a hamiltonian path in dg from s to t iff there is
hamiltonian path from s' to t' in ug.
proof: one direction is easy. given a hamiltonian path in dg, we can
easily construct a hamiltonian path in ug. for example, if
s--&gt;a---&gt;b---&gt;t was the hamiltonian path in dg, the hamiltonian path
in ug is

   s'--s_i--s_m--s_o--a_i--a_m--a_o--b_i--b_m--b_o--t_i--t_m--t_o--t'

now for the other direction. in any hamiltonian path in ug, for each
vertex v of dg, the vertices v_i, v_m, v_o must occur consecutively as 
v_i, v_m, v_o or as v_o, v_m, v_i because v_m is an interior vertex in
the path and v_m is connected to v_i and v_o only.
because the path begins with s', the initial segment must be
s'--s_i--s_m--s_o. there are no edges from v_o to u_o in ug, for any
vertices v and u in dg, so the only way this path can be extended to a
hamiltonian path in ug is for it to have the form

    s'--s_i--s_m--s_o--(a1)--(a2)-- ... --(ak)--t_i--t_m--t_o--t',

where each (aj) is an abbreviation for the (sub)path v_i--v_m--v_o for
some vertex v in dg. moreover, for each vertex v of dg, there is
exactly one j such that (aj) corresponds to v. suppose aj is the
vertex in dg corresponding to (aj).

this can easily be transformed to a hamiltonian  path in dg:

       s--&gt;a1--&gt;a2--&gt; ... --&gt;a_k--&gt;t

-- 
jayram s. thathachar                  jayram@cs.washington.edu
department of cse              http://www.cs.washington.edu/homes/jayram
university of washington              +1 206 616-1843 (vox)
box 352350, seattle, wa 98195         +1 206 543-2969 (fax)
sender: jayram@cs.washington.edu
date: fri, 31 may 1996 22:24:36 -0700
from: jayram thathachar &lt;jayram@cs.washington.edu&gt;
to: cse431@cs
subject: class web


the solutions to hws 4 and 5 are on the class web as well. 
good luck with the final!!!
-jayram.

-- 
jayram s. thathachar                  jayram@cs.washington.edu
department of cse              http://www.cs.washington.edu/homes/jayram
university of washington              +1 206 616-1843 (vox)
box 352350, seattle, wa 98195         +1 206 543-2969 (fax)






jayram@cs.washington.edu	
(last update: 
   
  03/26/96)




cse 431 bboard/mail log

cse 431 bboard/mail log

cse 431 bboard/mail log

cse 431 bboard/mail log

cse 431 bboard/mail log

cse 431 bboard/mail log

cse 431 bboard/mail log

cse 431 bboard/mail log

cse 431 bboard/mail log

cse 431 bboard/mail log