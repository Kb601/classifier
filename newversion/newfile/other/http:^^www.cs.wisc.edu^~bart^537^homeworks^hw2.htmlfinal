cs 537 - problem set #2






university of wisconsin-madison

computer sciences department




cs 537

spring 1996 
bart miller


problem set #2







problem 1

you are designing the memory mapping hardware for a new machine.
the memory addressing will have segments that are paged.
the machine has a 64-bit virtual address.
each process can have up to 64k (65536) segments, and page size
is 64k bytes.

the segment tables (st) and page tables (pt) are stored in main memory.
st's and pt's can start at any byte address.
each segment table entry (ste) points to a page table.

each page table entry (pte) points to a page in real memory.
each pte will also have:
a "read-enable" bit,
a "write-enable" bit,
and a bit that is set on each reference to the page.

this machine will support physical memories up to 64 gigabytes.


draw a diagram of this memory map.
show how the pieces of the virtual address are used to
reference each of the tables, and to generate the physical address.
indicate the size of each field, where it comes from, and where it is used.
also indicate where page faults or memory protection traps will be indicated.

how large (in bytes) is a full-sized st?

is it a good idea to have a "bounds" field in your ste's?
why or why not?
should this bounds field be in units of bytes or pages?

what happens if we double the page size (while still keeping a 64
bit virtual
address)?

problem 2


add a tlb to the memory mapping architecture that you described in problem 1.
this cache should be 4-way set associative and will have 256 rows.
draw a diagram of the tlb, showing the size of each field in the tlb.
indicate how bits of the va are used for input to the tlb, and describe the
outputs from the tlb.

how often do you need to flush (clear) the tlb?
why?
what change could you make to the tlb to avoid clearing it?

problem 3

for each of the following page replacement algorithms, describe a case
where the algorithm does a poor job in scheduling memory:
lru, lfu, fifo.
problem 4

consider a demand paging system.
we measure the various resource utilizations and see:

cpu utilization20%
paging disk99%


which of these (if any) should improve the cpu utilization?
why?


get a faster cpu.

get a bigger disk.

get a faster disk.

increase the degree of multiprogramming.

decrease the degree of multiprogramming.




cs 537 - problem set #2
cs 537 - problem set #2
cs 537 - problem set #2
cs 537 - problem set #2
cs 537 - problem set #2
cs 537 - problem set #2
cs 537 - problem set #2
cs 537 - problem set #2
cs 537 - problem set #2
cs 537 - problem set #2