homework 4
homework 4
  handed out: tue, mar 6th
  due: thu, mar 28th
  
  you are to find one partner for the term project, select a projet, and place a "1-page" proposal of what you want to do on the web. the proposal must address the following points: title, 1/2 "page" project description, goals, plan of attack, expected kind of results, how to determine sucess/failure, critical steps to get done soon. create a subdir in /vol/www/info/courses/current/cs516/projects and place the proposal there. name the file "welcome.html".
  here are some ideas that could lead to interesting projects. some of these are short-term, self-contained projects that could easily be accomplished within the context of a term-project. others could eventually expand into publications, or a meng project. if you pick a problem with a wider scope, you must be sure to isolate a piece that can be adequately addressed within the semester.
  you may work in teams of two, possibly three, but there should be a clearly identifiable role for each member of the team, especially for three person teams.
 1)  new
  high bandwidth cu-seeme
  couple split-c/u-net and split-c/solarismp
  build atm-fast ethernet gateway using u-net -- at ip level and/or at u-net level
  implement u-net kernel endpoints and run standard ip over u-net
  add ip packet filter to sba-200 firmware or to fast ethernet
  implement active messages flow-control for shared fast ethernet
  implement/port parallel gdb for split-c
  splash benchmarks
  perfect fast rpc u-net implementation (urpc) from last year
  perfect distributed shared memory from last year
  usit
 2)  instruction set design and measurement

condition codes or not, that is the question: (suggested by david wood) most architectures designed in the 1960s and 1970s employ condition codes. several of the recent risc architectures do not, yet others do. for example, the mips architecture does not have condition codes, yet it has set instructions that put the result of a comparison into a general purpose register. the rs/6000 has 8 (virtual) condition code registers, which can be set either as a side-effect of an alu instruction, or explicitly by compare instructions. explore the similarities and differences of these two schemes. is one clearly better than the other? are the differences technology dependent? as processors become increasingly integrated, which scheme will lead to the best performance?
analyze instruction issue strategies: analyze and compare scoreboarding, tomasulo's algorithm and the rs/6000 scheme. where's the beef? how much of the advantage of dynamic scheduling is achieved by static scheduling and delay slots? how do the trade-offs change with increased processor/memory speed ratio? are lock-up free caches or write-buffers critical? (i can pull together some good tools that students built at berkeley 1 1/2 years ago; they didn't have much time left to study the results, though, so you could leverage their work...)
address spaces beyond 32 bits: according to some observers, the demand for virtual address space increases at the rate of 1 bit every 2 years. thus, while 16 bit architectures were quite acceptable throughout the 60s and 70s, they eventually became too constraining, and have almost entirely been replaced. at this rate, we have just a few more years before 32-bit addresses begin to constrain our programs. some architectures have introduced segments to extend the address space. some computer architects suggest that only full 64-bit machines (integers and addresses) will solve the problems. explore the cost, performance, programming, and compatibility issues of these approaches. (most risc architectures have already defined a 64-bit extension&hellip; but we don't have any tools for analyzing the use of large address spaces and several interesting methodology issues arise in doing so.)
machine independent binaries: all risc instruction sets look almost identical, but you sure cannot compile one program for all. perhaps there is a middle ground, brand-x generic risc that could be easily mapped to a variety of isa with reasonable efficiency. (one such design has been developed pretty far by osf.) this raises another interesting question of machine independent pipeline scheduling.
powerpc vs. x86 architecture: compare the intel p6 processor to the ppc604 or ppc620. dig up all the technical information you can and try to come to terms with the real differences. the p6 is a risc processor at heart, so what's all this fuzz about old x86 code? does it really matter? the point of this project is to go further than the trade rags which beleive all the marketing hype as long as it boosts their sales...
validation of cache studies: using tools like spy or spix and piping the trace directly into an optimized cache simulator it is possible to evaluate substantial workloads of billions of instructions. review the literature and see whether the important published results on cache studies really hold up. in particular, what is the limit of spec based caching studies? at some point, all the spec programs fit into the cache.
 3)  superscalar, superpipeline
high-bandwidth data cache for superscalar architectures: what does it take to services several hits per cycle? to continue servicing hits while misses are being processes in the next bigger/slower level of the memory hierarchy? how much does this buy? try a sample design to get a feeling for the complexity. build a simple simulator and run some memory traces through it to see how much performance improvement is possible.
sophisticated branching for superscalar machines: (suggested by steve krueger, t.i.) in risc processors a pipeline break is relatively costly. in superscalar risc processors that cost is effectively multiplied by the number of instructions that execute simultaneously. it is therefore desirable to increase the runs of instructions without branches. some old architectures had skip instructions that were used extensively. it seems that skip instructions (possibly with restrictions on what could be skipped) could give conditional execution without breaking the pipeline through the use of squash or kill hardware already in place due to the needs of exception processing. study whether the number of cases where skip instructions could be effectively used is great enough to make them useful. skip-n forms might extend the usefulness by allowing more than one instruction to be skipped.
several variants of this idea could be considered, including multiway branches, conditional moves, operators to avoid branching (e.g., max, min, abs), and conditional operators.
register organization for superscalar machines: superscalar execution looks very attractive once the multiplier and floating point units fit on a chip, since at cpi>=1 these sit mostly idle. however, the cost increase comes in the memory system (see above) and the register file. to execute four instructions per cycle do we need a 12-port register file? many values are forwarded between functional units and never touch the register file! study register usage patterns in superscalar designs and see how the number of ports can be reduced. what are the cost/performance trade-offs?
 4)  multiprocessors

multiple processors on a chip: if you allow yourself a transistor budget of 10 to 50 million transistors on a chip you have plenty of room for innovative designs with multiple processors on a chip. this raises a host of interesting questions. should caches be shared or dedicated to individual processors? should floating point units be shared or dedicated? what is the trade-off between having more simpler processors vs fewer more sophisticated ones. in some sense this is trading instruction level parallelism against process level parallelism. the most serious bottleneck is going to be pin bandwidth in and out of the chip. how can you minimize the bandwidth requirement? are new protocols required? there are several ways to frame studies in this context. you may want to look at multiple independent processes, as in a workstation with many open windows, or a small shared-memory multiprocessor design, or you may want to look at this as a component in a massively parallel machine.
characterizing communication and sharing in multiprocessors: in current bus-based multiprocessors, interprocessor communication takes the form of cache misses. thus, several issues get folded into a single number: the miss rate. some good work has been done to try to characterize sharing in terms of modern cache organization, but there remains many unanswered questions. some of these may only be answered by inventing new analysis techniques. certainly it will be hard to get useful data. the reference string generated my each of the processors depends on how work is scheduled onto processors. this is generally done by allowing the processors to contend for various scheduling data structures. thus, the schedule is somewhat dependent on the memory system. exploring design variations relative to a fixed trace ignores this feedback. a thorough study needs to be done on the sensitivity or robustness of multiprocessor address traces. (a few other concerns have been raised, such as the number of shared references in available traces.)
communication with a co-processor using cache-cache transfers: several new multiprocessor designs use a second processor for the network interface and communicate between the main processor and the co-processor using cache-to-cache transfers. results indicate this is actually slower than one might at first expect. why? what alternatives are there? one suggestion is to have the opposite of a cache on the network interface processor: buffers which push data away into the right place in the memory system (e.g., large blocks into dram and small things into the processor cache).
what is the minimum cache miss rate due to communication: as uniprocessor caches get larger, the miss rate approaches the initial load cost (compulsory miss rate). it would seem that multiprocessor caches should tend toward the compulsory miss rate plus a communication factor. how would an optimal cache perform?
snoopy caches provide communication and replication of data. replication is what causes the coherence headaches. how does the miss rate (or communication rate) decrease with degree of replication?
distributed shared memory over atm: distributed shared memory (or virtual shared memory) has been around for a long time, but it never caught on. to a large degree this is due to the fact that ethernet is too slow to make it interesting. does atm change the picture? design and implement a dsm system over the atm network available in the dept. apparently willi zwanepoole at rice developed a nice implementation which could be adapted.
 5)  networking
the following projects make use of the atm network in the department, in particular of the user-level network interface that we've developed. they all deal with experimental software, so you have to be willing to hack around the bugs and gotchas!
ultra-fast tcp/ip implementation: normal implementations of tcp/ip are slow as hell. a big part of the problem is that tcp/ip normally sits in the kernel, but other problems have to do with the algorithms and implementations themselves. implement a really fast tcp over user-level atm and carefully analyze the performance. werner vogels has already a prototype ready. it needs some work on the connection set-up an tear-down, but othewise is already wuite fast. he has not done a lot of benchmarking and in particular no study of the performance under congestion has been done.
ultra-fast rcp implementation: this is similar to the above. review the literature on fast remote procedure call invocation implementations and implement one for the atm cluster of workstations.
atm multicast: the atm network supports multicast in the switch hardware. figure out how to control that and use it for some interesting application, e.g., horus or maybe video broadcasting.
 6)  applications
optimized application kernel implementation: pick your favorite compute-intensive application and beat the hell out of the compute-intensive part. for example, what is the fastest mpeg encoder/decoder you can build? the fastest motion detection algorithm for video scene analysis? the fastest compression/decompression? ... the key here is not just to arrive at a fast implementation but to do the analysis so you can convince others that you've arrived at the best possible implementation.

truth in specmarks: prepare your own small suite of benchmarks and compare the performance on several workstations to that predicted by the specmarks. it would be particularly interesting to put together an application specific suite: for example, a multimedia benchmark suite.
memory system behavior for large systems: study the memory system behavior (and maybe other processor performance parameters) for a full-fledged application. isis comes to mind: how can you measure the path length from the reception of a message all the way through the 1000's of lines of code `til a reply is sent back? or some other large system?
  


homework 4
homework 4
homework 4
homework 4
homework 4
homework 4
homework 4
homework 4
homework 4
homework 4