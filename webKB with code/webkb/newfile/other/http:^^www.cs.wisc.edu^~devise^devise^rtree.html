devise application examples



r-tree validation example




input data

the input data:

consists of three separate data sets, one for each level of the tree.
was produced by dumping the r-tree after it was bulk loaded (the data
in the tree is tiger geographic data from orange county, california).
contains the attributes: page id, level, x, y, width, height, and color.
(color is used to make it easier to distinguish the various nodes at
levels 2 and 3.)


the level 1 input file looks like:

1234 1 484402.500000 763222.500000 968413.000000 284401.000000 35
1234 1 1671075.500000 682544.000000 789569.000000 484602.000000 35
...


problem

we want to determine whether the r-tree bulk loading algorithm has produced
a "good" r-tree (not just one that is correct, but one that is
well-structured and will result in efficient searches of the data).

visualization

click here to see our model of creating
visualizations.

the visualization is created as follows:

define the 'rtree global picture' window.  this window simply displays
the level 1 data.
define the 'rtree levels 1-2' window, consisting of two piled views,
one of the level 1 data and one of the level 2 data.  one of these views
is the source for the cursor (the small yellow box) displayed in the
'rtree global picture' window.  this means that the area displayed in
the entire 'rtree levels 1-2' window corresponds to the area within
the cursor in the 'rtree global picture' window.
define the 'rtree levels 2-3' window.  this again consists of two
piled views, this time for levels 2 and 3 of the tree (level 3 is the
actual objects inserted into the tree).  the views in this window are
linked to the 'rtree levels 1-2' window, so that the region displayed
in the two windows is the same.



observations
this visualization was used to find some subtle bugs in the r-tree
bulk loading code.  these bugs would have otherwise been difficult
to find, because they did not produce incorrect results; rather, they
represented a suboptimal r-tree structure that would cause inefficient
searches of the data.

the data as it is shown represent the r-tree after the bugs were fixed.
when the bugs still existed, it was possible to find "bad" areas of the
r-tree by examining the visualization.

for more information on r-trees, see the paper 
using constraints to query r*-trees.