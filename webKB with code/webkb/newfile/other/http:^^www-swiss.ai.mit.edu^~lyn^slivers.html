slivers: computational modularity via synchronized lazy aggregates

franklyn turbak 

mit doctoral dissertation, februrary, 1994 

 abstract: 

slivers are a new approach to expressing computations as
combinations of mix-and-match operators on aggregate data.  unlike
other aggregate data models, slivers enable programmers to control
fine-grained operational aspects of modular programs.  in particular,
slivers can guarantee that networks of operators exhibit the desirable
storage behavior and operation scheduling of intricate loops and
recursions.  for example, slivers can preserve the space efficiency of
a complex tree algorithm when it is expressed as the superposition of
simpler tree walks.



the sliver technique is based on a dynamic model of lock step
processing that enables combinations of list and tree operators to
simulate the operational behavior of a single recursive procedure.
operational control is achieved through synchronized lazy
aggregates, dynamically unfolding data structures that constrain how
the processing of separate operators is interwoven.  the key to the
technique is the synchron, a novel first-class object that
allows a dynamically determined number of concurrently executing
operators to participate in a barrier synchronization.  slivers embody
a notion of computational shape that specifies how the
operational patterns of a process can be composed out of the patterns
of its components.



the utility of slivers is illustrated in the context of
synapse, a simple language for expressing linear and
tree-shaped computations.  synapse is built on top of
opera, a new concurrent dialect of scheme that incorporates
the concurrency, synchronization, and non-strictness required by the
lock step processing model.  the semantics of opera are
explained in terms of edgar, a novel graph reduction model
based on explicit demand propagation.



 contents: 

below are links to individual chapters of the disseration. 
for a more concise overview of key aspects of the thesis research, please
see the papers on synchronized lazy aggregates
and synchrons.



 
     table of contents
     

 
     acknowledgments
     

 chapter 1: 
     
     overview
     

  --  an overview of the dissertation. 

 chapter 2: 
     
     slivers
     
  --  a motivation for sliver decomposition in the context of two
  monolithic programs: an employee database program and an alpha
  renaming program.

 chapter 3: 
     
     the signal processing style of programming
     

  --  a detailed analysis of why existing sps techniques fail to express
  desirable operational characteristics of programs.

 chapter 4: 
     
     computational shape
     

  --  a presentation of a simple notion of computational shape.  shapes are
  described in terms of the time-based ordering induced on the call and
  return events in the execution of a recursive procedure.

 chapter 5: 
     
     synchronized lazy aggregates
     

  -- an explanation of the lock step processing model underlying the sliver
  technique. synchronized lazy aggregates are introduced as a mechanism
  for guaranteeing that networks of slivers simulate the behavior of a
  corresponding monolithic procedure.  


 chapter 6: 
     
     synapse: programming with slivers and slags
     

  --  an illustration of the power of slivers and slags in the context of
  synapse, a simple language for manipulating synchronized lists and
  trees.


 chapter 7: 
     
     opera: controlling operational behavior
     

  --  a presentation of opera, the concurrent dialect of scheme in which
  synapse is embedded.  an informal description of opera's concurrency, 
  synchronization, and non-strictness features is followed by an explanation 
  of how synapse is implemented in opera. 


 chapter 8: 
     
     edgar: explicit demand graph reduction
     

  --  an overview of edgar, an explicit demand graph reduction model that
  provides an operational semantics for opera.  opera's concurrency, 
  synchronization, and non-strictness mechanisms are formally described here.


 chapter 9: 
     
     experience
     

  --  a discussion of the experimental aspects of the research, including
  the implementation and testing of edgar, opera, and synapse.  this chapter 
  also describes the dynamator, a graphical program animator that proved 
  invaluable in the development of the other systems.


 chapter 10: 
     
     conclusion
     

  --  a summary of the research, including contributions and future work.


 
     bibliography 
     

 appendix a:
     
     glossary
     

  --  the dissertation introduces a large number of new terms, and uses some 
  existing terms in a non-standard way.  the glossary is provided to help the 
  reader adjust to the terminology.




select  here 
for a postscript viewer on the entire dissertation document. (warning: it is
454 pages long with lots of figures!).


 feedback: 



send all questions and comments about this work to
lyn@zurich.ai.mit.edu.