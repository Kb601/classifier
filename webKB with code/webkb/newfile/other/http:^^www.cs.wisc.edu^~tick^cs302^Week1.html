cs 302 section 70 lecture notes - week 1




 lecture notes - week 1




   topic:
   introduction to computers and programming.  how to use microsoft windows and microsoft fortran on the hewlett-packard vectra's

   text:
   chp. 1.1 - 1.5

   notes:
   

   

   
   introduction to fortran-77
   

   brief history
   
      one of the first high-level programming languages (circa 1957).
      forula translator.  good for engineering and scientific applications.
      fortran-77 (1977 revision) is the standard and most widespread version.  fortran-90 (1990 revision) has additional functionality but is not as widespread.
   

   why learn fortran instead of c++/pascal/basic/...
   
      easier to write complex formulas and equations.
      still widely used in engineering.
      lots of existing engineering program libraries are written in fortran.
      easy to learn, similar to basic.
   



   how to use fortran on the pc's
click  here 

   compiling steps
   
     source program (.for) in fortran sent to compiler
     compiler translates fortran into "machine language with a couple of holes left",spits out .obj file
     a program may be broken into lots of segments, so there may be other obj's around. at any rate, .objs must be linked together plus some other things needed to "fill in those holes" (don't worry about what the holes are). .obj files all read in, spits out .exe file (runnable machine language).
   
  
   inside the computer
   
       input: keyboard,mouse
       output: monitor,printer
       inside:
          
                     cpu: central processing unit. what does computations.
             memory: where the data is (the program itself and its data)
             removable storage. can take things off disk onto memory or back. must put things in memory in order to run it.
          

   

   memory and binary (to the tune of "ebony and ivory"...just kidding)
   
       each cell of memory (called a bit) either has a charge or has no charge. we call a charge 1 and no charge 0.
8 bits is one byte (a string of a combo of eight 0's and 1's). since each bit can be one of 2 things, 2 bits can be one of 4 things (00,01,10,11),3 bits can be one of 8 things (000,001,010,011,100,101,110,111), i.e. 2^n. so a byte lets us store up to 2^8 = 256 different patterns.
binary counting:

     decimal counts 0,1,2,3....9,10,11,....99,100,...999,1000
     ones place, tens place, hundreds place (i.e. 10^0,10^1,10^2...). this is because each digit can be one of 10 things (just as binary in the example above uses powers of 2).
     so in binary, we have ones place, two's place, four's place (i.e. 2^0,2^1,2^2...). take 1101, for example. in decimal, 1101 is 1x10^3 + 1x10^2 + 1x10^0. in binary, 1101 is 1x2^3 + 1x2^2 + 1x2^0 = 8+4+1 = 13.


machine language,assembly,fortran

dark ages(1960): since everything stored as 0's and 1's, everything is written that way. for example, 1101 might stand for "add". so 1101 0001 0011 0010 might mean "add whatever's in memory location 0001 to whatever's in 0011 and store the result in memory location 0010" (note the last three sets of digits refer to memory locations). you can't actually add to and from memory locations, so this is not quite a real example, but it gives you an idea of what's going on.
machine code is very hard to read. if you saw code like 1101 0001 0011 0010 1010 1111 1110 ... you'd go nuts. esp. since "add" takes 3 arguments, "move" takes 2 arguments, etc, so hard to tell which sets of numbers stand for commands (like "add") and which stand for memory locations.
solution: assembly language. add 0001 0011 0010. every machine lang. statement corresponds to one assembly statement, and vice versa.
problem. takes a loooong time to write out. you also have to worry about lots of details. programmers noticed that many times there were sequences of steps that were repeated quite a lot, such as

load 0001 %r1
load 0011 %r2
add %r1 %r2 %r3
store %r3 0010

(don't worry, you won't have to know this. this is just to show how tedious things were in assembly language). this says, take two memory locations and stick their values in registers. a register is a place where you do computations. it's separate from memory (cs354 explains how and why). so in order to compute you have to grab values from memory, stick them on registers, add the two registers into a third register, then store it back into memory somewhere else. whew! 
 instead, it'd be nice to just say sum = term1 + term2. this is a fortran statement which is  translated (compiled) into those assembly instructions you see above. you don't have to worry about where in memory sum,term1,and term2 are located...the compiler takes care of that for you. you don't have to worry about registers; again, the compiler does that. so four statements get compacted into one, and you don't even have to deal with binary!








copyright &copy 1996 modified fromjeff lampert (tick@cs.wisc.edu).  last modified september 11, 1996