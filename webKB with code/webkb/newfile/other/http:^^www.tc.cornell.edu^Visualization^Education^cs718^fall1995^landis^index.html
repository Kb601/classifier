sean landis' fall 718 context-based image retrieval project page

sean landis' cs718 project, fall 1995





content-based image retrieval systems for interior design


table of contents
introduction

background
..........manual image analysis
..........automated image analysis
..........image features
..........indexing and queries
current research
..........feature extraction
..........query specification
..........distance metrics
..........indexing
..........extensibility
..........artificial intelligence
..........maximizing domain knowledge
project overview
..........project definition
implemention
..........storage manager
..........analysis manager
..........query manager
..........display manager and the user interface
....................image menu
....................view menu
..........query by color algorithms
..........query by pattern algorithms
results
..........color queries
..........pattern queries
..........user interface
..........design
..........limitations
conclusions
..........usefulness
..........future work
references



introduction

computers are beginning to replace photographic archives as the preferred
form of repository. computer-based image repositories provide a flexibility 
that cannot be attained with collections of printed images. recently there has 
been an explosion in the number of images available to computer users.
as this number increases, users require more sophisticated methods of retrieval.
content-based image retrival (cbir) promises to fill this requirement.

there are many diverse areas where cbir can play a key role in the use of
images[1]:

 art galleries and museum management 
 architectural and engineering design 
 interior design 
 remote sensing and natural resource management 
 geographic information systems 
 scientific database management 
 weather forecasting 
 retailing 
 fabric and fashion design 
 trademark and copyright database management 
 law enforcement and criminal investigation 
 picture archiving and communication systems 
 education 
 entertainment 


with so many applications, cbir has attracted the attention of researchers 
across several disciplines.

 

background

content-based retrieval is based on an understanding of the 
semantics of the objects in a collection. semantic analysis is performed
when the object is inserted into the collection.
given a semantic representation of the objects in a collection,
a user can compose a query that retrieves a set of objects with
similar semantics. query analysis is usually performed on an index structure that
summarizes the data in the collection.

content-based image retrieval is the semantic analysis and
retrieval of images. semantic 
analysis may involve manual intervention, or it may be entirely 
automated. manual analysis involves human
interpretation to associate semantic properties with an image.
automated semantic analysis extracts image features that are 
correlated with some semantic meaning of the image. both analysis methods
have their advantages and their drawbacks.

 manual image analysis 

traditional databases use text key words as labels to efficiently access 
large quantities text data. even complex text data can be automatically
summarized and labeled using natural language processing and artificial 
intelligence[5]. 

when the data are images rather than text, summarizing the data with labels
becomes considerably more difficult. for example, consider a repository of
news photographs. a user may wish to pose a query such as

 give me all new photographs containing a us president and a 
communist leader.

to support queries like this, images require labeling that indicates
the people in the images, their title, their nationality,
and their political alignment.

it is not known how humans can process electromagnetic signals and convert
them into highly detailed semantic interpretations. therefore, human analysis
is required to generate labels that support sophisticated queries like the 
one above. but there are problems with human analysis:

 personal perspective
	 one person's interpretation
	of the important features of an image may not match another person's
	interpretation. personal perspective leads to variance in image analysis and labeling.
 domain mismatch
	 a person's domain of interest may influence image feature selection 
	and analysis.
 interface expressiveness
	human-computer
	interfaces provide a limited bandwidth of expressive capability. 
	image analysis os limited by the expressiveness of the interface.
 data entry errors
	humans are error-prone, especially 
	when set to a task which is tedious or redundant.

because of these, and other problems, it is best to 
automate image analysis as much as possible. where intervention is required,
the user should be limited to a set of unambiguous choices. 

 automated image analysis 

automated image analysis calculates approximately invariant statistics
which can be correlated to the semantics of the image data. example 
statistics are color histograms, invariants
of shape moments, and edges. statistical analysis is useful because it provides
information about the image without fickle and costly human interaction. 

despite its appeal, automated image analysis suffers drawbacks. the primary 
problem with statistical analysis is that extracted features can
only support a very specific type of query. the features apply to
a particular domain, but they are not useful for posing general purpose
queries against diverse data sets.

consider an image database indexed by color histogram. for each image, a feature vector is
generated such that each element of the vector represents the percentage of a color
quantum found in the image. a three element vector could have quantums representing
red, green, and blue (in practice a color feature vector requires more than three elements). 
the feature vector for an image contains the quantized
percentage of red, green, and blue. the more quantums available,
the greater the accuracy of the feature vector and the greater the cost of indexing and
comparison.

if the database contained fabric images, a color histogram would be a powerful way
to pose a query. a user interested designing a men's casual shirt for spring 
wants bright, spring-like colors. the query is posed with the desired color mix, and
all fabrics containing similar mixes of the specified colors are retrieved.
on the other hand, if the database contained news photographs as described earlier,
then color histograms would not be very useful. the semantics of the images in the
database do not correlate well with color histograms. 

 image features

an image feature is a piece of semantic information extracted from the image. there are
several properties for measuring the quality of a feature:

 capacity
	the number of distinguishable images that can be 
		represented[7]. 
 maximal match number
	the maximum number of images a query could possibly
		retrieve[7]. 
 complexity
	the amount of computation required to determine if two images are similar
		for a particular feature.
 compactness
	the amount of space required to store and compare a feature.


image features can be categorized as either primitive or 
logical[1].
a primitive feature is a low-level or statistical attribute of an image such as an object 
boundry or color histogram. primitive features are
automatically extracted directly from the image. a logical feature represents an abstract 
attribute such as the label grass assigned to a region of an image.
logical features rely on information beyond that contained in the image.

the delineation between primitive and logical features is not always clear. consider
an image which is a 2d representation of a 3d scene containing several objects. 
features representing the objects might be either primitive or logical features. if
the extraction 	generates a feature containing edge information, then it is
a primitive feature. on the other hand, if the extraction identifies the object by name,
say by utilizing a model-based approach, it is a logical feature.

primitive features are often used as the basis for generating logical features. a common 
cbir system architecture layers logical feature extraction on top of primitive 
featue extraction. primitive
features are extracted directly from the image to generate a segemented image.
from this information, more abstract, logical features are generated[6].
segementation is the process of dividing the image into regions that correspond to 
structural units of interest[10]. 

 indexing and queries

the goal of indexing is to create a compact summary of the database contents to
provide an efficient mechanism for retrieval of the data.
the summary data is based on feature vectors:


since in content based visual databases, all items (images or objects) are represented
by pre-computed visual features, the key attribute for each image will be a feature
vector which corresponds to a point in a multi-dimensional feature space; and search
will be based on similarities between the feature vectors. therefore, to achieve a
fast and effective retrieval...requires an efficient multi-dimensional indexing
scheme[11].


multiple indexing schemes may be required to support queries involving a 
combination of features. 
to utilize multiple indexes, a hierarchical approach is often used where each 
component of a query is applied against an appropriate index. a higher layer merges results
for presentation to the user.

cbir queries are posed in a fuzzy fashion. the user is typically interested in results
according to similarity rather than equality. this requirement influences the indexing 
scheme, the methods of feature comparison, and the means by which queries are 
solicited from the user. 

image similarity is usually determined by computing a distance measure between the
query and the appropriate feature vectors in the index structure. similar images
are ranked according to distance. thresholding may be used to reduce the number of 
similar images presented to the user.
 
a query is created by composing primitive and logical feature vectors. to present
a simple and structured query environment, cbir systems define query classes.
some typical query classes 
are[1]:


 color
	 a partial histogram is created by specifying colors and 
		percentages[3][6]
		[7][12][13]. 
 texture
	 texture features include directionality, periodicity, randomness, 
		roughness, regularity, coarseness, color distribution, contrast, and
		complexity[5][12]
		[13].
 sketch
	 the user creates a sketch representing an outline to be matched against
		dominant image edges[3][12].
 shape
	 an example shape is created using simple painting tools. the shape is 
		compared to objects within images for similarity[3]
		[4][12][13]
 volume
	 volumetric relationships are specified using 3d tools. feature vectors contain
		3d information.
 spatial constraints
	 the feature vector contains topological relationships among the objects in an image.
 browsing
	 the user is presented with a structured method of viewing the entire database.
 objective features
	 objective features are attributes such as date of image acquisition, 
		light direction, and view
		direction. these features lend themselves to the methods used in
		traditional databases[5][9].
 subjective features
	 feature extraction is manual or semi-automatic and is subject to human
		interpretation. examples are region labels and 
		manual object identification[5][9].
 motion
	 motion is applicable to a series of images such as video segments. motion features 
		measure movement of objects in the sequences or other movement such
		as camera viewpoint and camera focal point[3].
 text
	 either simple or complex text can be associated with images. for the 
		simple case, traditional database methods can be used. complex
		systems use natural language processing and artificial intelligence to
		reason about text annotations[5].
 domain concepts
	 domain information lends itself to specific forms of feature vectors and
		queries. 


query classes provide a meaningful way for a user to create feature vectors that
correspond to their notion of image semantics.
queries can be composed of multiple query classes. 

an alternative to user-composed queries are queries by example. the user submits
a query in the form of a prototype image and the system uses the feature vector(s)
of the appropriate query class(es). often a session will
begin with user-composed queries which are then refined through query by example.

to run an interactive query on a system called query by image content (qbic), 
click
 here. 
 




current research

there are a large number of researchers exploring cbir-related topics. 
i focused on recent work which has been more productive. 
the following sections describe some of the important topics i studied.

feature extraction 

feature extraction is performed when an image is added to the database. cbir systems
provide support for multiple query classes.
pickard and minka[5] use 6 different 
features to characterize images from the mit photobook image retrieval system.

the core system[6], is a retrieval engine that 
supports a wide range of features including
visual browsing, color similarity measures, and text. primitive features are combined
to create higer level, logical features they call concepts. 

the qbic system[3][12] extracts features
that support image query classes for color, texture, shape, sketching, location,
and text. the system also supports a set of video oriented query classes. 

for color histograms, many different extraction methods are used. the first issue
is the dimension of the color feature vector, e.g., the number of colors. typical
numbers range from 64 to 256 dimensions (256 being the number of unique colors
representable with one byte).
the higher the dimension of the feature vector, the greater its capacity.

the values in each bin of a color histogram are usually either the total number
of pixels, or the percentage of pixels for the given color in 
the entire image.
 
query specification

the papers i read treated query specification as a secondary issue. 
researchers recognized the need for simple ways to specify queries. unlike
text-based databases where the desired information is retrieved with
a single query, a suitable image may require many queries. 
cbir systems typically return several of the best images for selection
by the user. many systems allow the user to select one of these images as an
example for another query. this is an example of query refinement.
researchers are exploring ways of providing easy refinement of queries that
yield high success.

the use of multiple query classes to compose
a query interests researchers. 
although many systems claim to support composite queries, few of the
papers explained how to combine query classes successfully.

distance metrics

most image query classes rely on similarity metrics rather than exact matching. 
distance metrics produce a relative distance between two image feature vectors.
a threshold is used to determine if two features are similar.
in many cases, the user can control the threshold to relax or constrain a query.

every distance metric has advantages and drawbacks. for example, 
stricker[7] analyzes two common distance metrics, the l1 and
l2 (euclidean) norms. the l1 norm computes the distance d 
between two n element color histograms h and i as:






and the l2 norm is computed as:






stricker states that "using the l1-metric results in false negatives, i.e., not all 
the images with similar color composition are retrieved because the l1-metric does
not take color similarity into account. using a metric similar to the l2-metric
results in false positives, i.e., histograms with many non-zero bins are close to
any other histogram and thus are retrieved always."

the qbic system[12] uses a 64 or 256 dimension color histogram where
each i-th element is the percentage of color i. the distance 
between histogram r and database image histogram q is
computed as (r - q)t a(r - q). where t is the transpose operator.
the locations a(i,j) in a contain the distance between color
i and color j.

ibm's ultimedia manager[13] uses a 64-dimensional vector of color
percentages. each dimension represents a range in color space. at analysis time
the color of each pixel is quantized into one of the 64 ranges based on its location
in rgb space.

indexing

the predominant cbir research is in the area of image feature indexing. there are
many difficult problems to solve. first, image features are typically high dimensional
requiring complex, multi-dimensional indexing. second, traditional indexing assumes
exact matching; similarity matching complicates the indexing structure.
finally, it is difficult to combine multi-dimensional, similarity-based indexing
methods to efficiently support queries composed of mutliple query classes.

by using similarity metrics only for initial indexing, pickard and 
minka[5] avoid the problem of combining query classes with
different metrics. similarity is encoded into clusters of image regions in a tree
structure and distance is measured by ancestral distance between clusters. this
has the effect of normalizing different query classes so they can be treated 
identically.
 
extensibility

systems must be extensible to overcome the immaturity of indexing methods, 
query specification, and feature extraction. most of the important
work in cbir lies ahead. 

the importance of extensibility
was recognized by wu, et. al.[6] when they
developed core based on a generic framework for a multimedia dbms. to demonstrate
the flexibility of the architecture, they developed two different applications: a
computer-aided facial image inference and retrieval system (cafiir), and a trademark
archival and registration system (star). a medical information system is currently 
in development. in their conclusion, they state: "object orientation is very
important for a retrieval engine like core. one advantage...is an increase in
the reusability of codes...to increase its reusability and extensibility."

artificial intelligence

research focuses on three applications of artificial intelligence to cbir: reasoning
about logical features, similarity metrics, and index construction and maintenance.
for example, pickard and minka[5] apply ai when annotating 
images to dynamically select
from multiple feature models based on how the user labels image regions. their system 
is also capable of improving the indexing structure based on new positive and negative
examples.

wu, et. al.[6], apply fuzzy reasoning to queries where the logical
features of the query are only partially defined by the user. they also used a
learning based on experiences
neural network model to generate self-organizing nodes
in a content-based index tree. this allows their system to fuse composite feature 
measures to support complex and fuzzy queries. 

maximizing domain knowledge

query performance can be drastically improved in cases where assumptions can be made
about the nature, or domain, of the images in the database. wu, et. al., observe that 
"core has comprehensive functions. however each application has its domain-specific
problems." and "in application development, domain expertise must be added to customize
the indexing and retrieval module."




project overview

 exploration of cbir problems in the domain of interior design.
i am interested in the methods of cbir which apply to 
problems faced by interior designers. interior designers work with paint, wallpaper, 
fabric, and floor coverings. they also follow general principles of form,
space, color, and style. designers and their customers regularly face the
tedious chore of manually searching for, and matching materials according to
general design principles and taste. there is an opportunity for a high degree 
of computer assistence with these tasks.

designers could compose queries using primitive and logical features and
specify constraints according to design principles. results
of a series of queries, for wallpaper, paint, and carpet, must be
self-consistent according to designer-specified rules of form, space, color,
and style. these requirements led my interest toward the following query
classes:

  color 
	 fabric, wallpaper, etc., are often selected based upon color
		content. this is a perfect application of color histograms.
  texture 
	 floor coverings, wallpaper, and fabric all have important textural
		components ideal for queries based on textural features.
  shape 
	 examples of shapes are stripes, plaids, floral and patterns.
  objective features 
	 styles such as victorian could be modeled as objective features.
  subjective features 
	 taste, mood, or sensation related design concepts can be specified using subjective
	feature queries. examples are: feminine vs. masculine, cheery, cool, warm, etc.
  text 
	 product attributes such as part numbers, supplier information, and first
	production date are all text features.
  domain specific 
	the design rules described above are domain specific features.


query by example is a powerful tool for interior designers. for
example, given a particular carpet sample, the designer could find window 
covering that compliments the carpet.

 project definition 

i implemented
a software prototype that allowed me to explore the following areas: 

 color
	 color is an important feature of the materials interior designers
	use. color also allows automatic image analysis. i explored a few
	implementations of color histogram feature vectors and related
	similarity metrics.    
 pattern
	 patterns are also very important to interior designers. i
	focused on automated feature vector generation using edge detection. 
 software design
	 one of the difficulties of cbir systems is that no small number of
	query classes provide enough flexibility to support interior design. 
	further, the technology of image feature vectors, 
	similarity metrics, and indexing is immature. a
	real-world system needs to be extensible and configurable. using
	object oriented techniques, i designed a system that encapsulates the areas
	of highest change. i created a framework to support the addition of new query 
	classes and distance metrics. the framework divides major system 
	tasks among manager objects that interact through well-defined interfaces. 
 user interface
	 i defined a simple user interface for color histogram queries and
	provided the ability to query by example using color histograms and shapes.
 image management
	basic to a qbic system is the ability to efficiently manage the performance,
	storage, and memory requirements of images. because of their size and complexity,
	images have special computation and resource
	requirements. i have identified some of
	these issues and suggest some solutions.


i specifically avoided exploring indexing issues in this project.




implementation

i implemented a software prototype for the purpose of exploring the details of cbir.
the software was written using microsoft(tm) visual c++ compiler, version 2.0. the
platform was a intel 486dx2 system running the windows nt operating system,
version 3.51. the software architecture is shown in the following block diagram:





this architecture is loosely based on core[6]. each of the
managers is implemented as a singleton object; the class
definition restricts instantiation to only one system-wide object.

 storage manager 

the storage manager provides an interface to the image database. it is responsible for 
maintaining an in-memory virtual mapping of images and for performing system specific 
i/o operations. the following class diagram[14] depicts the key 
relationships.





the storagemanager class, stormgr.h, provides 
member functions to access the image database. a client uses store()
to associate the pixmap in file with the image object and store
the image in the database. this function is used by the analysismanager to
process a user request to add an image to the database. it also attaches the
pixmap to the image which allows the analysismanager to perform
feature extractions on the image.

clients can request a single image using getimage(), or the entire image 
database list using getimagelist(). the loaddb() function is used
to initialize the storagemanager object.

the current implementation of the storagemanager maintains an unordered list of
image objects representing the entire database. in a real system, the
storagemanager would maintain multiple indices used to retrieve
images. the image objects would be at the leaves of the index, e.g., 
in the case of a tree-based index structure. 

for efficiency, this implementation only loads the pixmap data for an image when
necessary. the image object determines when to load the data;
the task of loading is delegated to the storagemanager.

the image class, image.h, encapsulates the details
of the pixmap implementation and feature vectors. the system manipulates 
image objects for convenience. the pixmap class provides an interface to 
a color pixel representation of an image
(pixmap.h). this class allows the implementation of the  on-screen
image to change without affecting the rest of the code.

the features class, features.h, encapsulates a set
of feature vectors. this class allows new feature vectors to be added
as new query classes are added.

two changes would be required in a production system to efficiently manage memory.
first, the current implementation only loads pixmaps on demand and never 
invalidates them. invalidating pixmaps would conserve large amounts of physical 
memory. a typical pixmap requires 512 x 512 = 262144
bytes of memory just to store the image data, assuming 256 colors. also a
pixmap has a color table and other overhead making for a total of about
264000 bytes. 

a second memory saver would be the use of thumbnail versions of the pixmaps. thumbnails
are smaller representations, usually 64 x 64 = 4096 bytes, which are used for 
display. the current system only requires the entire image during feature 
extraction. support for thumbnails would either require a time
tradeoff to reduce a large pixmap when it is loaded into memory, or a disk space tradeoff
if the thumbnails were generated at load time and stored in the database.

 analysis manager 

the analysis manager, analmgr.h performs
analysis on images as they are added to the system. the result is a set of feature
vectors, one for each type of query class. the greatest
change in a cbir system is likely to be the addition of new query
classes. the analysis manager provides extensibility via registration of
feature extractors which generate feature vectors. the class relationships are shown
in the following class diagram.





when a user adds a new image to the system, the user interface calls the 
analyze() member function. this function uses the storagemanager
to create a new image which it then analyzes by calling extract()
on each installed
feature extractor. new feature extractor objects are added by calling
addfeature() when the system is initialized.
  
the featureextractor abstract class provides an interface definition to be
used by all feature extractors (features.h).
concrete feature extractor classes inherit the interface
and provide implementations appropriate for the needs of the feature vectors they
generate. a feature extractor object is responsible for analyzing the image, creating
a featurevector, and installing the featurevector in the feature
object of the image.

the featureextractor classes play an important role: they encapsulate all 
important information for a particular query class. when adding a new query class,
most of the effort is in creating a new subclass of featureextractor. other
classes can get query class specific information 
from feature extractors. for example, the querymanager calls the
similarityfunc() when comparing two images.

the analysismanager, feature extractors, features, and
the featurevector have an important relationship. at initialization
time, all the feature extractors are installed into the singleton instance of
the analysismanager (init.cpp). the analysismanager
tells each feature extractor its position in the set of feature vectors stored in
the features objects. it also tells the features class how many 
feature vectors every features object must be capable of storing.
every feature extractor implementation knows how large to make the
data portion of its featurevector. by encapsulating knowledge in this fashion,
new features can easily be added. 

 query manager 

the querymanager class provides two important functions: the ability to query
the database, and the ability to maintain a query history
(querymgr.h). the query manager accepts a features 
object and a similarityfunc() from the user interface and formulates a 
query. the formulated query is used to retrieve similar images
from the storage manager. a client requests an initialized
features object from the analysismanager, (which knows the position
and size information for every feature), and fills it in with the information to be
matched in the query. the client gets the similarityfunc from the feature
extractor class defined for the query class. 

similarity functions are static member functions of the derived feature extractor class.
this is necessary when passing a member function pointer as a function argument.
they accept two features objects and compute a distance between them.  
similarity functions must return a non-negative value representing the
distance between the feature vectors. the function can also optionally return a
value less than zero if the two feature vectors
are dissimilar. the querymanager uses the return value to rank
images by distance. after the querymanager completes the processing of a query, it passes the
ranked list of images to the displaymanager for presentation.   

the current implementation contains similarity functions that only operate upon a 
single query class. since the specifics of the similarity computation are external
to the querymanager it is possible to provide similarity functions which take
into account multiple query classes. one way to do this is to provide a
hierarchy of queries in which the results of one level of queries are passed to
a different similarity function.

 display manager and the user interface 

the display manager, displmgr.h, is responsible for displaying
images on the screen and tracking mouse selection of images. 
this class is closely related to the user interface provided
by the operating system. it maintains the list of currently displayed images and
responds to paint messages generated by the window system.






a client of the display manager can submit a list of images by calling 
display(). this will replace the existing list
of images held by the display manager with the list passed to this function.
then the images will be displayed.

note that the image lists that many of the manager objects maintain are lists
of pointers to image objects. to avoid memory leaks, clients pass a
deletion policy to the display() member function telling
the displaymanager how to manage the memory in the image list.

the user interface provides typical menu options according to the windows(tm) style.
to see a screen capture showing the application area filled with wallpaper
images, click  here.
each image has a label which is the name of the database file containing the pixmap.

image menu

the image menu provides options for adding images and for querying the database. 
selecting
a query option presents a dialog designed to solicit a query for a particular query
class. for example, the following screen capture shows the dialogs used to compose a
 query by color.

composing a color query is a multi-step process involving two dialogs. 
the query by color dialog allows the user to specify up to 3 color 
percentages for the query. to specify each color, the user manipulates the controls
in the color dialog. this is a standard windows dialog that allows selection
of colors directly from the system color palette. the user may also create up to sixteen
custom colors.

once the query is composed, the user presses the ok button and the query is
submitted to the querymanager. all similar images will be displayed by the
displaymanager.
  
view menu

the view menu provides selections that allow the user to view information about
the database and its images. the database item causes the displaymanager
to display the entire image database. in a real application, this would be impractical;
intelligent browsing tools would be necessary for traversing a large set of images.

selecting the features... item presents the user with the image features
dialog containing a list box of
all the image names. the user selects an image and presses the desired button in
the display group. the following screen capture shows what happens after the
colorhistogram button is  pressed.

the color histogram dialog presents two histograms of the selected image. the
original image histogram is the color histogram of the image as stored in the
database. each bar represents the relative number of pixels that are assigned the 
displayed color. the total color bins field is the number of bins in each
histogram, and the total empty bins field is the number of bins which do not
contain any pixels.

the image feature histogram is the histogram of the feature vector. it is
a quantized version of the original histogram. a high 
percentage of empty bins in the feature histogram is common.

selecting the pattern histogram button from the image features
dialog, presents the pattern histogram dialog. 
the dialog shows the directional bias of the image. the numbers below each of 
the three bins represent the relative biases in each direction. the 
integer values range
between 0 and 3 representing weak, not strong, strong, and very strong. the dialog
shows that the image is very strongly biased vertically and strongly biased 
horizontally.

the color values... item on the view menu presents the user with 
a dialog for viewing the predominant  feature colors.
the image color values dialog displays the five most prevalent colors, their 
percentage of distribution,
and their rgb value. the color and the rgb values shown are the value at 
the center of each quantization range. this dialog 
is very useful for testing the quality of the similarity function.

query by color algorithms

when an image is added to the database, the analysismanager calls the 
extract() member function on the colorhistogram object,
clrhistx.h. this function is responsible for creating
a query class specific feature vector and installing it in the image.

colorhistogram creates a 64-dimensional color histogram feature vector
similar to the one used in ibm's ultimedia manager[13].
each element of the feature vector represents a cube-shaped subspace of rgb
space as shown in the following figure.   






each pixel is quantized into one of the bins. after traversing the image, the
histogram contains the number of pixels contained in each color cube. each 
bin value is then converted to a percentage representing the relative number
of pixels contained in that color cube.

the similarity function of colorhistogram
computes the distance between two histograms using th l2 norm.
this distance is compared to a user-definable
threshold value to determine similarity. the 
querymanager uses the return value to order images, most similar first.

the l2 norm only works well on sparse matrices. this is fine when
the user provides three colors via a dialog because only
entries with values are compared. when querying by example, the similarity function
ignores small percentages if they are present in both histograms, reducing the 
problem of false positives due
to contribution of insignificant differences between histograms.

query by example requires a larger similarity threshold since it
usually involves many more comparisons than queries
via the dialog. for the data i used,
9.0 to 24.0 worked for three color queries and 25.0 to 40.0 
was good for query by example.

query by pattern algorithms

query by pattern algorithms automatically recognize the
directional biases of an image.  
when an image is added to the database, the analysismanager calls the 
extract() member function on the pattern class, 
patternx.h.
pattern creates a 3-dimensional feature vector where each element
contains a percentage of bias in the horizontal, diagonal, and vertical directions.

the pattern extraction algorithm is a multistep process. first it creates
a greyscale copy of the original image. rgb values are converted to 
brightness values using the same translation as for black and white television.
television images are transmitted using the yiq color scale. black and white
television recievers only display the y portion, the luminance signal:







the greyscale image is then processed to detect edges using the sobel 
operator[10]. this method applies two 3 x 3 kernels to the 
nieghborhood of each pixel to estimate the brightness derivatives 
db/dx and db/dy. for the derivative in the horizontal direction,
the following kernel is used:


			 1   0  -1
			 1   0  -1
			 1   0  -1


and for vertical direction, the following kernel is used:


			 1   1   1
			 0   0   0
			-1  -1  -1


conceptually, a kernel is applied to an image by sliding the kernel over the image
and summing the products of the values in the kernel with the brightness values under
them. the result is the derivative, or brightness slope at the pixel under the center
of the kernel.
after the application of both kernels to a pixel nieghborhood, the magnitude is computed:






this value is assigned to the pixel under the center of the kernel. to emphasize the
edges, the algorithm thresholds the value to black or white. the following image
is a result of this process:


 


finally the edge image is traversed applying the two kernels again. this time the
derivatives are much stronger in the bias of the image. the direction of the slope is
determine by:







this is a value between zero and pi. the algorithm quantizes the direction into one
of the three bins in the histogram. after this process is applied to the entire
image, the sums in the bins are converted to percentages.

the result is a feature vector containing percentages of bias in horizontal,
diagonal, and vertical directions. the distance metric ranks the three 
direction biases as: very strong, strong,
not strong, and weak. it then computes the l1 norm
distance between the two histograms. this distance is compared to a user-definable
threshold value to determine similarity. the returned distance is used by the 
querymanager to order similar images.




results

the results of my project were positive. using a scanner, i was able
to produce on-line pixmaps for 50 wallpaper samples. i implemented 
software that supported both color and pattern based queries of a wallpaper database.
the software provides an intuitive user interface and supports easy addition of new
query classes. 

color queries

there are two ways to query the database by color: dialog and
example. the query by color dialog was described above.
a dialog query using three user-selected colors demonstrates the effectiveness of the 
query. three images are returned in order of similarity.

an example-based query uses the color histogram of a displayed wallpaper sample as
the query key. the user clicks the right mouse button on the desired example and
is presented with a popup menu. selecting query by color example will initiate
the retrieval. stripe7.bmp was used as the example
wallpaper image and the threshold was set at 38.

pattern queries

the software currently supports pattern queries by example only. the
example-based queries are initiated from a popup menu. a query based on wallpaper
sample plaid1.bmp results in a set of wallpapers
containing strong directional bias in vertical and horizontal directions. 
this query was restricted to display 10 images. 

the current implementation
does not provide enough capacity to distinguish between directional bias from lines
and bias from noisy patterns. this would require a more sophisitcated 
feature extraction algorithm. for example, a smoothing step could be used to supress
the noise before performing the gradient computations.

user interface

the user interface is fairly intuitive. the interface presents a familiar 
environment to the windows user by following 
microsoft windows interface guidelines. 

a sample user, unfamiliar with image processing, easily navigated through
the system. the user was confused about the meaning of the
threshold parameters which must be set as numbers. this confusion
could be alleviated by presenting a slider control representing a scale of
relative distance.

design

the software design i used takes full advantage of object-oriented principles. the
key features of the design are:

 change is encapsulated
	 the area of greatest change is the addition of new query classes. this
	functionality is encapsulated in the feature extractor concrete classes. 
	a new query class is added by copying an existing feature extractor
	and modifying it to suit the needs of the new query class.   
 implemenation details are encapsulated
	 two classes hide implementation details: pixmap and 
	storagemanager. to support multiple image types, pixmap could
	be converted into an abstract class providing only interface; specific image types
	would inherit from this class. the storagemanager class hides
	details of the database and operating system and is responsible
	for logical image management. in a full-featured application,
	the storagemanager would delegate system details to another class, and
	would only manage images.
 abstraction is enforced
	 abstraction is enforced using well-defined manager classes.
 interface inheritance eases expansion
	 the featureextractor abstract class defines the interface for all
	concrete feature extractors. client code can be written
	to an interface without knowledge of query class-specific details.


ghese design principles produced an extensible and embeddable system. 

the prototype could be made embeddable by converting it to 
a server in a client/server arrangement. first, the user interface
code must be externalized. this code is sensitive to change and properly resides in
the client application. second, a client/server communication protocol must be used. 
in the microsoft windows environment, ole would provide this capability.

limitations

the limitations of the prototype are performance and resource
management. adding a new image to the database takes a long time because of 
image analysis. although the current algorithms are not optimized, this step 
will always be too expensive to perform in real time. a production system would have
so many feature vectors that a batch processing mechanism would be necessary.
 
image management is too crude for a production system. the entire image
database is 
loaded into memory and no mechanism exists for maintaining only 
a working subset of images.
there is no support for thumbnail versions of images. the size of an
image is about 512x512 even though the software always scales down to
64x64 for display.

the software is a prototype intended for exploring ideas and
therefore does not contain the polish required in production systems.




conclusions

the project goals were met: a prototype cbir system was built demonstrating color
and pattern queries; an intuitive user interface provides ease of use; an 
object-oriented design supports extensibility and embeddability. 

usefulness

with the
vast number of images available on-line, quality cbir systems are critical. by
using the right system, people can quickly find the image they need.
 
in the field of interior design, designers and their 
customers search through hundreds of carpet,
drapery, paint, and wallpaper samples. their selections must be combined to create
a pleasing result. producing an 
asthetic result often requires even more searching. 

through the use of cbir, designers could access vast amounts of material, (either
on cd-rom or in a vendor database), and rapidly create high-quality
interior decorating solutions. sophisticated query environments could assist in
applying practical design constraints to ensure attractive results.
expensive sample inventories would be obsolete. significant savings would be
passed on to customers.

future work

a cbir system for interior design requires access to large databases of
flooring, paint, fabric, and wallpaper samples. efficient
retrieval from multiple, large, image databases relies on new data representations
and indexing methods. these methods must support 
queries composed of multiple query classes.

more and better query classes are needed to support all aspects of interior
design materials. classes for color, texture, pattern, and style are needed to 
create asthetic designs. text and other attributes are necessary to represent 
manufacturer information, wear characteristics, cost, etc.

judicious use of artificial intelligence will improve system performance. fuzzy logic
is useful in determining image similarity for certain query classes. 
expert systems can be built that assist designers in creating solutions that conform to 
traditional design idioms.

finally, sophisticated user interfaces will be needed to give designers the power and
flexibility their work demands. users must be able to incrementally build design 
solutions. the interface must provide access to designers' portfolio so they
can use and modify past work allowing quick response to customer demands.

there are many challenges ahead for future cbir systems builders. the field of interior
design presents its own challenges. the results of my work show promise, but there
is still much to do.




references

[1] venkat n. gudivada, vijay v. raghavan:   
content-based image retrieval systems,
ieee computer, september 1995.


 
[2] a. desai narasimhalu: 
special section on content-based retrieval,
multimedia systems, 1995, 3:1-2.


 
[3] flickner, sawhney, niblack, et. al.: 
query by image and video content: the qbic system ,
ieee computer, september 1995.


 
[4] rajiv mehrotra, james e. gray: 
similar-shape retrieval in shape data management ,
ieee computer, september 1995.


 
[5] r. w. pickard, t. p. minka: 
vision texture for annotation ,
multimedia systems, 1995, 3:3-14.


 
[6] j. k. wu, a. desai narasimhalu, b. m. mehtre, c. p. lam, y. j. gao: 
core: a content-based retrieval engine for multimedia information systems ,
multimedia systems, 1995, 3:25-41.


 
[7] markus a. stricker: 
bounds for the discrimination power of color indexing techniques ,
proceedings spie storage and retrieval for image and video databases ii, 1994, 15-24.


 
[8] nagarajan ramesh, ishwar k. sethi: 
feature identification as an aid to content-based image retrieval ,
proceedings spie storage and retrieval for image and video databases iii, 1995, 2-11.


 
[9] virginia e. ogle, micheal stonebraker: 
chabot: retrieval from a relational database of images ,
ieee computer, september 1995, 40-48.


 
[10] john c. russ: 
the image processing handbook ,
second edition, crc press, 1995.


 
[11] hong jian zhang and di zhong: 
a scheme for visual feature based image indexing ,
proceedings spie storage and retrieval for image and video databases iii, 1995, 36-46.


 
[12] jonathan ashley, ron barber, myron flickner, james hafner,
denis lee, wayne niblack, dragutin petkovic: 
automatic and semi-automatic methods for image annotation and retrieval in
qbic ,
proceedings spie storage and retrieval for image and video databases iii, 1995, 24-35.



 
[13] harold treat, ed ort, jean ho, mimi vo, jing-song jang,
laura hall, frank tung, dragutin petkovic: 
searching images using ultimedia manager ,
proceedings spie storage and retrieval for image and video databases iii, 1995, 204-213.


 
[14] james rumbaugh, michael blaha, william premerlani,
frederick eddy, william lorensen: 
object-oriented modeling and design ,
prentice hall, 1991.





cs718 course description




send questions and comments to sean landis at 
scl@isis.com

last modified 12/7/95 by sean landis