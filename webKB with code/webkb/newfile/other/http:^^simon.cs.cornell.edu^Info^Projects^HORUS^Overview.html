overview of the horus project






































overview of the horus project


five years ago, 

kenneth birman and 
robbert van renesse 
started the activity that ultimately lead to
the design of horus.  at the outset, the project was perceived as a redesign of
the 
isis 
group communication system.  isis, although successful, was
unix-specific, monolithic (and hence, inflexible), and used protocols
that have subsequently been improved upon.
over the last five years, horus evolved beyond these initial goals,
becoming a sophisticated group communication system with an emphasis
and properties considerably different from those of its "parent" system.

perhaps the best general overviews of horus can be found in the april 1996
issue of communications of the acm, and in the may 1996 issue of 
scientific american.  many additional papers are available in our online
technical reports area.

readers already familiar with group communication will best understand horus
as a general-purpose 
communication architecture that also does a very good job of supporting
the sorts of process-group applications for which isis became popular.  
broadly, horus is a flexible and extensible process-group communication
system, in which the interfaces seen by the application can be varied
to conceal the system behind more conventional interfaces, and in which
the actual properties of the groups used (membership, communication, events 
that affect the group) can be matched to the specific needs of the 
application.  if an application contains multiple subsystems with differing
needs, it can create multiple superimposed groups with different
properties in each.  the resulting architecture is unique in being
completely adaptable: the groupware developer or systems programmer pays
only for properties that are specifically desired, and can often
use horus to introduce reliability or replication in a completely
transparent manner.

users who wish to treat horus as a prebuilt system can take advantage
of its virtual synchrony model to introduce replication, coordination,
and fault-tolerance into their applications.  horus is suitable for
building high performance groupware applications and we are now working
on real-time applications, notably in the area of telecommunications
switch management.  several interfaces are available for direct use
of horus, including a toolkit named hots, oriented towards c++ programmers.

for users who wish to develop new groupware protocols, horus
can be viewed as a group communication environment rather than as a
collection of prebuilt groupware solutions.  it is
unix-independent, and permits the use of several programming languages (c, c++,
ml, and python) in a single system.  horus protocols are structured
like stacks of lego-blocks, hence new protocols can be developed
by adding new layers or by recombining existing ones.
through dynamic run-time layering, horus permits an application to
adapt the protocols it runs to the environment in which it finds itself.

much of our research has been on the issues associated with
developing layered groupware protocols.
over time, horus
layers have become much simpler than expected, and consequently
lend themselves to
automatic verification.  this is especially true for the horus
layers coded in ml, which are well suited to analysis using the
nuprl
system (also a cornell research project).
by combining simple layers, complex semantics
can be supported.  

existing horus protocol layers include an implementation of 
virtually synchronous process groups (a technique permitting consistent
and fault-tolerant data replication), as well as protocols for
parallel and multi-media applications.  considerable recent work has been  
done on protocols for secure group computing and for real-time
applications.  moreover, horus is now at a point
where the communication protocols can be upgraded underneath a running
application, without the need to stop and restart the application.

although layered protocol architectures often carry a performance penalty,
horus includes a protocol accelerator that permits it to demonstrate
excellent performance.  horus supports a
corba request broker, 
a fault-tolerant multi-media toolkit, a fault-tolerant www server, and a cooperative text
editor.  

on the theoretical side, the project has contributed
a significant body of fundamental results in
the overall areas of distributed fault-tolerance, consistency,
security and private communication in group-communication systems.
current work includes study of how properties can be proved for 
composed stacks consisting of multiple layers, basic theoretical work
on virtual synchrony, and study of systems that combine real-time and
logical consistency properties.

looking to the future, we believe that horus will be well matched to
the replication needs of emerging web applications such as caching
web proxies; cornell students have implemented prototypes of such
systems successfully.  horus can be used as a java communication
protocol, and is appropriate for system management in complex large-scale
internet settings.  other likely application areas 
include transparent fault-tolerance
options for limited classes of applications, security and system
monitoring, and database replication.

the horus 
software is available for use by research
laboratories.  commercial use of the technology should be possible by
late in 1996 or early 1997, through an arrangement with stratus computers
inc.


project funding.


arpa has played a significant role in the progress made by the horus project 
by providing long-term funding through the office of naval
research under contract n00014-92-j-1866.

the horus research effort is grateful to ibm research, gte, siemens,
corporation and stratus computer inc. for support of our effort.


comments to
werner vogels