my life at the keyboard



computers have been part of my culture all my life.  my father worked
for ibm.  every so often we'd visit him at work, and see the huge
computer rooms.  sometimes he'd bring home pieces of computers for us
to see. but i had no idea what these things really did.  they were
just cool looking.  sometime when i was 16 or 17 my father brought
home some ibm documentation on programming languages and flowcharting.
i tried to read them, but they did not make any sense to me - but this
is not surprising, since ibm isn't exactly famous for clearly written
documentation.

  in 1973, i came to mit.  during the first few weeks, i went on a
tour of the mit artificial intelligence laboratory, which in those
days included the logo lab.  i don't remember why i went on the tour,
but i remember that i was with several other freshmen with whom i
lived at my fraternity - but i can't recall if we were all together at
the ai lab because we were together as new members of the frat, or
whether i came to join that frat because of liking the people i met at
the ai lab.  the former seems more likely, especially since the house
had a strong representation at the ai lab.  in any event, we were
playing with logo and were left pretty much alone - we had to figure
it out by ourselves.  we had a lot of fun with it.

  so as an undergraduate i would sometimes come to the ai lab to
play (or "hack") with logo, and i began to learn to program.  i don't
remember anyone teaching me - i think we must have taught each other.
sometimes i would try to use lisp on the pdp-10 but it was too
mysterious for me to figure out.  that summer, i worked for ibm as an
operator - a low-level position calling for about as much skill as an
espresso maker.  but in my spare time at work i was allowed to use the
computer language apl, and this time i found a textbook for the
language so i was able to learn some of it.  i still had no idea how
languages actually worked.  i just used them.

  in my sophomore year, i took the course 6.031 (which is the
ancestor of the course now known as 6.001).  this course explained how
a computer language could be designed using a simpler language as
building blocks.  it also tried to give us some sense of the ideas of
modularity and top down design, and most crucially, the idea of
abstraction - that one can make a program which represents some
concept or set of agreements, and thereafter use it without needing to
know how the concept was implemented.  the program becomes a "black
box" whose internal details are irrelevant. 

 
later that year i took a second course which explained how the simplest sorts of
computer languages (machine language) could be implemented by hardware circuits.
i was now able to understand computer programming down to the level of
individual "logic gates", if i wanted to.  this reinforced my sense of the value
of keeping different levels separate in order to build large, complex structure.
 later, though, i would learn that one of the hardest problems is deciding where
to draw the modularity lines, and that putting one's borders in the wrong place
makes a system slow and difficult to use.

  the next major step in learning programming was a student job at
the architecture machine group (which is an ancestor of the media
laboratory).  in those days, a group of students at the arcmac were
developing a new operating system for use around the lab.  the
operating system, being new, was full of bugs, and these in turn
demanded that there be constructed many software tools for examining
the structures used by the program.  i had the opportunity to look
over the shoulders of those who were more experienced, and even to use
the tools a bit to poke around.  it was while using one of these tools
that i suddenly understood that there is no actual meaning in the
patterns of binary ones and zeros in machine, and no significant
difference between the information on a disk and in the
machine's memory.  a given region of memory can be an instruction, or
a number, or a letter, or a picture.  the difference is solely a
matter of interpretation.  this was perhaps the biggest "aha" in my
life, and i was happy that other people were around
who could understand it and why it mattered.

 
it was while working at this same job that i began to think not just about how
to make a program do something but how to make it easy for someone else to use.
this was also a step towards being a professional programmer, a worker who makes
artifacts for others to use, not just for his/her own delight in making it.  it
was also during this time that i also began to be good enough a designer that
other people started taking my ideas for design and function seriously.

  after i graduated, i began to work in the real world as a
programmer.  my first job was at imlac in needham ma.  the imlac was a
minicomputer (what you'd call a workstation now) that was sort of an
expanded pdp-8 with a built in vector display processor.  it was
programmed in assembly language.  imlac's big product was a
phototypsetting system, ces, which took advantage of the raster
graphics to offer a kind of wysiwyg interface for the typesetting.
this was before laser printers.

 i kept this first job only a year, and then moved to a new job
with the (honeywell) multics
multics is an operating system of great historical importance.  it was
first developed as a partnership by mit and general electric as an
experiment in a practical, very large time-sharing system.  at the
time, it was the very cutting edge of the state of the art in computer
science.  by the time i joined the multics group, those days were
past, but the group retained some measure of pride, and still had very
high standards, even though time had passed them by.  i learned
several important ideas from working with the multics people.  first,
my understanding of "interface" (the relation between a program and a
user) expanded to include the idea that the user might be another
programmer.  it was important to make programs as building blocks by
programmers whose needs you could not expect to easily anticipate.  a
second idea was that programs were meant to be read by people as well
as machines.  the multics group had developed a programming
process which required that all modification to the system be
described and justified to a group of senior programmers before being
written, and be read by some person other than the author before being
installed.  this was necessary because multics was far too large for
any single person to understand it.  the coordination that this review
board provided kept multics stable and consistent as it grew and
changed for more than 15 years.  though multics is now nearly
forgotten, it set a mark for software quality never equalled.  working
with multics taught me to be careful in my designs, to always to allow
room for unanticipated future changes, and to expect people to read my
programs.

  in my work at multics i came to know many people, but one of
particular note was bernie greenberg.  bernie was one of the most
brilliant programmers i have ever met.  in addition, he was a very
talented musician, playing both rock guitar and baroque harpsichord
with equal ease, and he spoke several languages.  bernie also
re-introduced me to lisp.  at that time, the mit artificial
intelligence laboratory was developing the first lisp machines and
bernie was friends with several of the key workers on this project.  i
learned lisp from bernie not long before he left multics to join a new
startup company to commercialize the lisp machine.  i soon left as
well, to join logo computer systems, a new firm which intended to
implement a version of logo for the apple ii home computer.

  
logo computer systems was the first time i was ever with a
startup firm.  instead of the formal regulations of multics, i was
with an adhoc group which included several close friends and lovers,
as well as some bizarre personalities.  at lcsi we worked very, very
hard, because we knew that money was in short supply.  we would often
work for 16 to 20 hours in a row.  we did almost all our work in lisp,
on lisp machines, and i gradually became an expert with this language.
in the end, we managed to produce our product on time, but then most
of us left the company as a result of political battles with the
higher management.

 
this turned out to be a blessing though, because alan kay had just gone to
atari, which was then quite rich, and alan was setting up research labs in
california and cambridge.  almost the entire boston staff of lcsi came to form
the atari cambridge research center.  atari gave us money to design the best
work environment we could think of, and freedom to work on problems that
interested us.  not only was i able to work on music, i was able to hire one of
my friends, tom trobaugh, to work with me.  at atari i knew the happiness of
working with a partner on problems we really cared about using the most powerful
computers available.  alas, atari began to lose money, and one day it closed the
lab.

 after atari went under i enrolled in the mit's media lab, as one
of the first contingent of doctoral students.

the media lab

the media lab encourages students to set their own directions, in fact
it insists on it.  this has both pros and cons.  the advantage is that
you learn to be independent, to think outside the common assumptions
of the field.  the drawback is that you don't always have the
companionship of others while learning.  in my own case, i became
interested in the linguistic phenomenon called "paraverbals", those
inarticulate noises like "uh huh" and "hmmm" that help make
conversation run smoothly.  there's a pretty large literature on the
subject, but i had to discover it on my own, and i'm sure it would
have gone faster with a guide.  on the other hand, with an experienced
authority controlling my learning, i wouldn't have done what i did.

 
the other important thing about the media lab is the constant focus on
demonstrating one's work.  some people complain about it, but it's
very important.  to do a good demo, you have to be able to explain
what you're doing and why it matters to a smart but uninformed person
with just a few short sentences.  you have to learn to be clear, and
you have to learn to express your idea for the benefit of the learner,
not the teacher.  and you have to learn grace under pressure.
i wish everyone learned these skills.

 

one of the first projects i worked on was the "phonetic dictionary".
remember when you were a kid, and you asked a grown-up for the meaning
of a word, and they told you to look it up in the dictionary?  that's
a fine idea, except it's hard to do when you've only heard the word,
and so don't know how it's spelled.  this is especially true for
english, with its bizarre spelling rules.  the phonetic dictionary
allows you to look up a word by spelling it according to how it
sounds, not how it's spelled.  you write some approximation of the
sound of the word, and the system consults a dictionary that's
organized by pronunciation.  the key to the thing was being able to
accept a wide range of "phonetic" spellings.  for example, for the
word "headache" you might write "hedayk" or "hedake".  i was pleased
to see this project mentioned on the very first page of stewart
brand's book about the lab.

 
my supervisor was chris schmandt, known to all by his login name
"geek". i could write at length about his knowledge, but there are
lots of smart people in the world.  he has two qualities that are more
rare.  first, he's no autocrat.  you can argue with him.  there's no
way to put on an air of superiority when you call yourself "geek".
second, and even more valuable, he kept his perspective.  in
particular, he was always taking off for a week or two at a time to
bring his (then) baby daughter out into the wilderness.
i learned from him that a computer will happily sit idle for a week,
while a week lost from fathering is gone for ever.

 
my major project was the "back seat driver", which was a car that
could give you driving instructions in the city of boston.  it had a
street map (so it knew the roads), a navigation system (so it knew
where it was), and a speech synthesizer (so it could talk to you.).
to actually make this work, i needed a car, and not just any car.  the
navigation system was supplied by our sponsor, a japanese electronics
firm, and was designed to work with only one type of car, a top of the
line luxury sedan.  i also needed not one but two cellular phones in
the car for the communications.   the media lab bought me what i
needed and i kept the keys.  i was surely the only graduate student in
the usa with such lab equipment.

 
  one day i was demonstrating the back seat
driver to a group from general motors.  when i took them out for a
ride, they had a great time shooting pictures of each another getting
into a japanese car.  off we went driving.  as usually happened, at
one point the driver missed a turn.  normally, the consequence was
that the bsd would calmly inform the driver of the fact and plan a new
route, only in this case, the driver was a former race car driver, and
he quickly made an (illegal) u turn without even slowing down, a
maneouver even seasoned boston drivers never attempted.  this caused
the program to crash, but i guess that's better than crashing the car.


  i'll have to add something here about the demise of lisp machines
and the rise of unix, and about becoming obsolete.